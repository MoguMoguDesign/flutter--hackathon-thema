# Implementation Plan: Firebase Project Setup

**Date**: 2025-11-29 17:12:22
**Branch**: feature/firebase-setup
**Issue**: [#7 Firebase プロジェクトセットアップ](https://github.com/MoguMoguDesign/flutter--hackathon-thema/issues/7)
**Priority**: High (Phase 1: 基盤構築)
**Based on**: docs/investigate/investigate_20251129_170813.md

---

## Executive Summary

This plan provides a granular, step-by-step implementation strategy for integrating Firebase into the Flutter Hackathon Thema project. The implementation strictly follows the three-layer architecture (App → Feature → Shared) and includes comprehensive test coverage.

**Estimated Total Effort**: 1 hour (as specified in Issue #7)

**Breakdown**:
- Phase 1: Dependencies & Configuration (15 minutes)
- Phase 2: Firebase Initialization (10 minutes)
- Phase 3: Shared Layer Services (15 minutes)
- Phase 4: Security Rules (10 minutes)
- Phase 5: Testing (10 minutes)

---

## Implementation Strategy

### Architecture Compliance

**Three-Layer Placement**:

1. **App Layer** (`lib/main.dart`):
   - Firebase initialization only
   - Error handling for initialization failures
   - NO business logic

2. **Shared Layer** (`lib/shared/`):
   - Firebase service utilities
   - Base repository classes
   - Common Firebase operations
   - Reusable across all features

3. **Feature Layer** (Future work):
   - Feature-specific repositories extending Shared base classes
   - NOT part of Issue #7 scope

**Dependency Flow Verification**:
- App → Shared ✅
- Shared → (no dependencies) ✅
- NO Feature → Feature ✅
- NO Shared → App ✅

### Technology Stack Compatibility

| Package | Current Version | Required Version | Compatible? |
|---------|----------------|------------------|-------------|
| Flutter | 3.35.1 | >=3.24.0 | ✅ Yes |
| Dart | 3.9.0 | >=3.9.0 | ✅ Yes |
| hooks_riverpod | 3.0.3 | ^3.0.0 | ✅ Yes |
| firebase_core | N/A | ^4.2.1 | ✅ Add |
| cloud_firestore | N/A | ^6.1.0 | ✅ Add |
| firebase_storage | N/A | ^13.0.4 | ✅ Add |

---

## Phase 1: Dependencies and Configuration

**Estimated Time**: 15 minutes

### Task 1.1: Add Firebase Dependencies

**File**: `pubspec.yaml`

**Action**: MODIFY

**Changes**:
```yaml
dependencies:
  # ... existing dependencies ...

  # Firebase (ADD THESE)
  firebase_core: ^4.2.1
  cloud_firestore: ^6.1.0
  firebase_storage: ^13.0.4
```

**Steps**:
1. Open `pubspec.yaml`
2. Locate the `dependencies:` section
3. Add Firebase packages after existing packages
4. Maintain alphabetical order within Firebase group
5. Ensure proper YAML indentation (2 spaces)

**Acceptance Criteria**:
- [ ] All three Firebase packages added
- [ ] Versions specified with caret (^) notation
- [ ] YAML syntax valid (no indentation errors)
- [ ] Packages added after existing dependencies

**Commands**:
```bash
# Verify YAML syntax
fvm flutter pub get
```

**Expected Output**:
```
Running "flutter pub get" in flutter--hackathon-thema...
Resolving dependencies...
+ cloud_firestore 6.1.0
+ firebase_core 4.2.1
+ firebase_storage 13.0.4
```

### Task 1.2: Install FlutterFire CLI

**Action**: INSTALL TOOL

**Commands**:
```bash
# Install FlutterFire CLI globally
dart pub global activate flutterfire_cli
```

**Acceptance Criteria**:
- [ ] FlutterFire CLI installed successfully
- [ ] CLI accessible from terminal

**Verification**:
```bash
flutterfire --version
```

**Expected Output**:
```
FlutterFire CLI version: 1.x.x
```

### Task 1.3: Configure Firebase for Web

**Action**: RUN CONFIGURATION TOOL

**Commands**:
```bash
# Configure Firebase project
flutterfire configure --project=myaku-haiku --platforms=web
```

**Interactive Prompts**:
1. "Which platforms should your configuration support?" → Select "web" (space to select, enter to confirm)
2. "Which Firebase apps would you like to use?" → Select "Create a new app" or choose existing Web app
3. Confirm configuration

**Generated Files**:
- `lib/firebase_options.dart` (auto-generated, do not edit manually)
- `.dart_tool/package_config.json` (updated)

**Acceptance Criteria**:
- [ ] `lib/firebase_options.dart` generated
- [ ] File contains `DefaultFirebaseOptions` class
- [ ] Web platform configuration present
- [ ] Project ID matches "myaku-haiku"

**Verification**:
```bash
# Check if file exists
ls -la lib/firebase_options.dart

# Verify content contains project ID
grep "myaku-haiku" lib/firebase_options.dart
```

**Expected Content Preview**:
```dart
// lib/firebase_options.dart
import 'package:firebase_core/firebase_core.dart';

class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    return web;
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: '...',
    appId: '...',
    messagingSenderId: '...',
    projectId: 'myaku-haiku',
    authDomain: 'myaku-haiku.firebaseapp.com',
    storageBucket: 'myaku-haiku.appspot.com',
  );
}
```

---

## Phase 2: Firebase Initialization

**Estimated Time**: 10 minutes

### Task 2.1: Update main.dart

**File**: `lib/main.dart`

**Action**: MODIFY

**Current Code**:
```dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'package:flutterhackthema/app/app_router/app_router.dart';

/// アプリケーションのエントリーポイント
///
/// Riverpodの[ProviderScope]でアプリ全体をラップして状態管理を有効化
void main() {
  runApp(const ProviderScope(child: MainApp()));
}
```

**New Code**:
```dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';

import 'package:flutterhackthema/app/app_router/app_router.dart';
import 'package:flutterhackthema/firebase_options.dart';

/// アプリケーションのエントリーポイント
///
/// Firebase初期化後、Riverpodの[ProviderScope]でアプリ全体をラップ
/// して状態管理を有効化する。
///
/// Firebase初期化エラーは開発環境でログ出力され、本番環境では
/// エラーハンドリングが必要。
Future<void> main() async {
  // Flutterフレームワークの初期化を確実に完了
  WidgetsFlutterBinding.ensureInitialized();

  try {
    // Firebase初期化（Web用設定を自動選択）
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
  } catch (e, stackTrace) {
    // Firebase初期化エラーをログ出力
    // TODO(#7): 本番環境ではエラーページへのリダイレクトを検討
    debugPrint('Firebase initialization error: $e');
    debugPrint('Stack trace: $stackTrace');
  }

  runApp(const ProviderScope(child: MainApp()));
}
```

**Changes Summary**:
1. Add `firebase_core` import
2. Add `firebase_options` import
3. Change `main()` to `Future<void> main() async`
4. Add `WidgetsFlutterBinding.ensureInitialized()`
5. Add Firebase initialization with try-catch
6. Update Japanese documentation comments
7. Add TODO comment for production error handling

**Acceptance Criteria**:
- [ ] All imports added correctly
- [ ] main() function is async
- [ ] Firebase.initializeApp() called before runApp()
- [ ] Error handling with try-catch present
- [ ] Japanese documentation comments updated
- [ ] TODO comment added for future work
- [ ] No breaking changes to existing MainApp class

**Testing**:
```bash
# Run app to verify initialization
fvm flutter run -d chrome

# Check for Firebase initialization in console
# Should see: "Firebase initialized successfully" or no error
```

---

## Phase 3: Shared Layer Firebase Services

**Estimated Time**: 15 minutes

### Task 3.1: Create Firebase Service Utility

**File**: `lib/shared/service/firebase_service.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';

/// Firebase サービスの基本ユーティリティクラス
///
/// Firestore と Storage のインスタンスへのアクセスを提供します。
/// このクラスは状態を持たず、静的メソッドのみを提供します。
///
/// 使用例:
/// ```dart
/// final firestore = FirebaseService.firestore;
/// final storage = FirebaseService.storage;
/// ```
class FirebaseService {
  // プライベートコンストラクタ（インスタンス化を防止）
  FirebaseService._();

  /// Firestore インスタンスを取得
  ///
  /// Cloud Firestore データベースへのアクセスを提供します。
  /// このインスタンスはアプリ全体で共有されます。
  ///
  /// Returns:
  ///   [FirebaseFirestore] のシングルトンインスタンス
  static FirebaseFirestore get firestore => FirebaseFirestore.instance;

  /// Storage インスタンスを取得
  ///
  /// Firebase Storage へのアクセスを提供します。
  /// このインスタンスはアプリ全体で共有されます。
  ///
  /// Returns:
  ///   [FirebaseStorage] のシングルトンインスタンス
  static FirebaseStorage get storage => FirebaseStorage.instance;
}
```

**Directory Structure**:
```
lib/shared/service/
├── .gitkeep (DELETE this placeholder file)
└── firebase_service.dart (CREATE)
```

**Acceptance Criteria**:
- [ ] File created at correct path
- [ ] Private constructor prevents instantiation
- [ ] Static getters for firestore and storage
- [ ] Comprehensive Japanese documentation
- [ ] Usage example in doc comments
- [ ] Follows project coding style

### Task 3.2: Create Base Firestore Repository

**File**: `lib/shared/data/repositories/firestore_repository.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'package:cloud_firestore/cloud_firestore.dart';

/// Firestore リポジトリの抽象基底クラス
///
/// 全ての Firestore リポジトリが実装すべきインターフェースを定義します。
/// 各Featureは、このクラスを継承して具体的なリポジトリを実装します。
///
/// 型パラメータ:
///   [T] - リポジトリが扱うモデルの型
///
/// 使用例:
/// ```dart
/// class PostRepository extends FirestoreRepository<Post> {
///   @override
///   String get collectionPath => 'posts';
///
///   @override
///   Post fromFirestore(DocumentSnapshot doc) {
///     final data = doc.data() as Map<String, dynamic>;
///     return Post.fromJson(data);
///   }
///
///   @override
///   Map<String, dynamic> toFirestore(Post model) {
///     return model.toJson();
///   }
/// }
/// ```
abstract class FirestoreRepository<T> {
  /// Firestore のコレクションパス
  ///
  /// 継承クラスで実装する必要があります。
  /// 例: 'posts', 'users', 'comments'
  String get collectionPath;

  /// Firestore への参照を取得
  ///
  /// Returns:
  ///   このリポジトリが管理するコレクションへの参照
  CollectionReference<Map<String, dynamic>> get collection {
    return FirebaseFirestore.instance.collection(collectionPath);
  }

  /// Firestore ドキュメントからモデルに変換
  ///
  /// Parameters:
  ///   [doc] - Firestore ドキュメントスナップショット
  ///
  /// Returns:
  ///   型[T]のモデルインスタンス
  T fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc);

  /// モデルを Firestore ドキュメントに変換
  ///
  /// Parameters:
  ///   [model] - 変換するモデルインスタンス
  ///
  /// Returns:
  ///   Firestore に保存可能な Map
  Map<String, dynamic> toFirestore(T model);

  /// ID でドキュメントを取得
  ///
  /// Parameters:
  ///   [id] - ドキュメントID
  ///
  /// Returns:
  ///   見つかった場合はモデルインスタンス、見つからない場合は null
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<T?> getById(String id) async {
    final doc = await collection.doc(id).get();
    if (!doc.exists) {
      return null;
    }
    return fromFirestore(doc);
  }

  /// 全てのドキュメントを取得
  ///
  /// Returns:
  ///   モデルインスタンスのリスト（空の場合もあり）
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<List<T>> getAll() async {
    final snapshot = await collection.get();
    return snapshot.docs.map((doc) => fromFirestore(doc)).toList();
  }

  /// 新しいドキュメントを作成
  ///
  /// Parameters:
  ///   [model] - 作成するモデルインスタンス
  ///
  /// Returns:
  ///   作成されたドキュメントのID
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<String> create(T model) async {
    final docRef = await collection.add(toFirestore(model));
    return docRef.id;
  }

  /// IDを指定して新しいドキュメントを作成
  ///
  /// Parameters:
  ///   [id] - ドキュメントID
  ///   [model] - 作成するモデルインスタンス
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<void> createWithId(String id, T model) async {
    await collection.doc(id).set(toFirestore(model));
  }

  /// ドキュメントを更新
  ///
  /// Parameters:
  ///   [id] - 更新するドキュメントのID
  ///   [model] - 更新後のモデルインスタンス
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<void> update(String id, T model) async {
    await collection.doc(id).update(toFirestore(model));
  }

  /// ドキュメントを削除
  ///
  /// Parameters:
  ///   [id] - 削除するドキュメントのID
  ///
  /// Throws:
  ///   [FirebaseException] - Firestore アクセスエラー時
  Future<void> delete(String id) async {
    await collection.doc(id).delete();
  }
}
```

**Acceptance Criteria**:
- [ ] File created at correct path
- [ ] Abstract class with generic type parameter
- [ ] All CRUD operations defined
- [ ] Comprehensive Japanese documentation
- [ ] Usage example in doc comments
- [ ] Error documentation (throws clauses)
- [ ] Follows project coding style

### Task 3.3: Create Base Storage Repository

**File**: `lib/shared/data/repositories/storage_repository.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'dart:typed_data';
import 'package:firebase_storage/firebase_storage.dart';

/// Storage リポジトリの抽象基底クラス
///
/// Firebase Storage へのファイルアップロード・ダウンロード機能を提供します。
/// 各Featureは、このクラスを継承して具体的なリポジトリを実装します。
///
/// 使用例:
/// ```dart
/// class ImageStorageRepository extends StorageRepository {
///   @override
///   String get basePath => 'images';
///
///   Future<String> uploadPostImage(Uint8List imageData, String postId) async {
///     return uploadFile(imageData, 'posts/$postId.jpg', 'image/jpeg');
///   }
/// }
/// ```
abstract class StorageRepository {
  /// Storage の基本パス
  ///
  /// 継承クラスで実装する必要があります。
  /// 例: 'images', 'videos', 'documents'
  String get basePath;

  /// Storage への参照を取得
  ///
  /// Returns:
  ///   このリポジトリが管理する Storage への参照
  Reference get storageRef {
    return FirebaseStorage.instance.ref().child(basePath);
  }

  /// ファイルをアップロード
  ///
  /// Parameters:
  ///   [data] - アップロードするファイルデータ
  ///   [path] - Storage 内のパス（basePath からの相対パス）
  ///   [contentType] - ファイルのMIMEタイプ（例: 'image/jpeg', 'image/png'）
  ///
  /// Returns:
  ///   アップロードされたファイルのダウンロードURL
  ///
  /// Throws:
  ///   [FirebaseException] - アップロードエラー時
  ///
  /// Example:
  /// ```dart
  /// final url = await uploadFile(
  ///   imageBytes,
  ///   'posts/image1.jpg',
  ///   'image/jpeg',
  /// );
  /// ```
  Future<String> uploadFile(
    Uint8List data,
    String path,
    String contentType,
  ) async {
    final ref = storageRef.child(path);
    final metadata = SettableMetadata(contentType: contentType);

    // ファイルをアップロード
    final uploadTask = await ref.putData(data, metadata);

    // ダウンロードURLを取得
    final downloadUrl = await uploadTask.ref.getDownloadURL();

    return downloadUrl;
  }

  /// ファイルをダウンロード
  ///
  /// Parameters:
  ///   [path] - Storage 内のパス（basePath からの相対パス）
  ///
  /// Returns:
  ///   ダウンロードされたファイルデータ
  ///
  /// Throws:
  ///   [FirebaseException] - ダウンロードエラー時
  ///
  /// Example:
  /// ```dart
  /// final imageData = await downloadFile('posts/image1.jpg');
  /// ```
  Future<Uint8List?> downloadFile(String path) async {
    final ref = storageRef.child(path);
    return ref.getData();
  }

  /// ファイルを削除
  ///
  /// Parameters:
  ///   [path] - Storage 内のパス（basePath からの相対パス）
  ///
  /// Throws:
  ///   [FirebaseException] - 削除エラー時
  ///
  /// Example:
  /// ```dart
  /// await deleteFile('posts/image1.jpg');
  /// ```
  Future<void> deleteFile(String path) async {
    final ref = storageRef.child(path);
    await ref.delete();
  }

  /// ファイルの存在確認
  ///
  /// Parameters:
  ///   [path] - Storage 内のパス（basePath からの相対パス）
  ///
  /// Returns:
  ///   ファイルが存在する場合は true、存在しない場合は false
  Future<bool> fileExists(String path) async {
    try {
      final ref = storageRef.child(path);
      await ref.getMetadata();
      return true;
    } catch (e) {
      return false;
    }
  }

  /// ダウンロードURLを取得
  ///
  /// Parameters:
  ///   [path] - Storage 内のパス（basePath からの相対パス）
  ///
  /// Returns:
  ///   ファイルのダウンロードURL
  ///
  /// Throws:
  ///   [FirebaseException] - URLの取得エラー時
  Future<String> getDownloadUrl(String path) async {
    final ref = storageRef.child(path);
    return ref.getDownloadURL();
  }
}
```

**Acceptance Criteria**:
- [ ] File created at correct path
- [ ] Abstract class with base path property
- [ ] Upload, download, delete operations defined
- [ ] File existence check included
- [ ] Download URL getter included
- [ ] Comprehensive Japanese documentation
- [ ] Usage examples in doc comments
- [ ] Follows project coding style

---

## Phase 4: Security Rules Deployment

**Estimated Time**: 10 minutes

### Task 4.1: Create Firestore Security Rules

**File**: `firestore.rules`

**Action**: CREATE (in project root)

**Full Implementation**:
```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Posts コレクション
    match /posts/{postId} {
      // 誰でも投稿を読むことができる
      allow read: if true;

      // 投稿作成は必須フィールドの検証付き
      // - nickname: 文字列型、1-20文字
      // - haikuText: 文字列型、1-100文字
      // - imageUrl: 文字列型、HTTPSで始まる
      // - createdAt: タイムスタンプ型
      allow create: if request.resource.data.keys().hasAll([
                         'nickname',
                         'haikuText',
                         'imageUrl',
                         'createdAt'
                       ])
                       && request.resource.data.nickname is string
                       && request.resource.data.nickname.size() >= 1
                       && request.resource.data.nickname.size() <= 20
                       && request.resource.data.haikuText is string
                       && request.resource.data.haikuText.size() >= 1
                       && request.resource.data.haikuText.size() <= 100
                       && request.resource.data.imageUrl is string
                       && request.resource.data.imageUrl.matches('https://.*')
                       && request.resource.data.createdAt is timestamp;

      // MVP版では更新・削除は禁止
      allow update, delete: if false;
    }
  }
}
```

**Acceptance Criteria**:
- [ ] File created in project root
- [ ] Rules version 2 specified
- [ ] Posts collection rules defined
- [ ] Read access is public
- [ ] Create validation includes all required fields
- [ ] Field type and size validations present
- [ ] Update and delete operations blocked
- [ ] Japanese comments for clarity

**Deployment**:
```bash
# Deploy Firestore rules
firebase deploy --only firestore:rules
```

### Task 4.2: Create Storage Security Rules

**File**: `storage.rules`

**Action**: CREATE (in project root)

**Full Implementation**:
```javascript
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    // Posts 画像ディレクトリ
    match /posts/{imageId} {
      // 誰でも画像を読むことができる
      allow read: if true;

      // 画像アップロードは以下の条件を満たす必要がある:
      // - ファイルサイズ: 最大 5MB
      // - ファイル形式: 画像のみ（image/*）
      allow create: if request.resource.size < 5 * 1024 * 1024
                    && request.resource.contentType.matches('image/.*');

      // MVP版では更新・削除は禁止
      allow update, delete: if false;
    }
  }
}
```

**Acceptance Criteria**:
- [ ] File created in project root
- [ ] Rules version 2 specified
- [ ] Posts images directory rules defined
- [ ] Read access is public
- [ ] Create validation includes size limit (5MB)
- [ ] Create validation includes content type check
- [ ] Update and delete operations blocked
- [ ] Japanese comments for clarity

**Deployment**:
```bash
# Deploy Storage rules
firebase deploy --only storage:rules
```

### Task 4.3: Verify Security Rules Deployment

**Commands**:
```bash
# Verify Firestore rules deployed
firebase firestore:rules:get

# Verify Storage rules deployed
firebase storage:rules:get
```

**Acceptance Criteria**:
- [ ] Firestore rules deployed successfully
- [ ] Storage rules deployed successfully
- [ ] No deployment errors
- [ ] Rules visible in Firebase Console

---

## Phase 5: Testing

**Estimated Time**: 10 minutes

### Task 5.1: Add Testing Dependencies

**File**: `pubspec.yaml`

**Action**: MODIFY

**Changes**:
```yaml
dev_dependencies:
  # ... existing dev_dependencies ...

  # Firebase Testing (ADD THESE)
  fake_cloud_firestore: ^3.0.3
  firebase_storage_mocks: ^0.7.0
```

**Commands**:
```bash
fvm flutter pub get
```

**Acceptance Criteria**:
- [ ] Testing dependencies added
- [ ] Packages installed successfully

### Task 5.2: Create Firebase Service Tests

**File**: `test/shared/service/firebase_service_test.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';

import 'package:flutterhackthema/shared/service/firebase_service.dart';

void main() {
  group('FirebaseService', () {
    test('firestore getter returns FirebaseFirestore instance', () {
      // Arrange & Act
      final firestore = FirebaseService.firestore;

      // Assert
      expect(firestore, isA<FirebaseFirestore>());
      expect(firestore, equals(FirebaseFirestore.instance));
    });

    test('storage getter returns FirebaseStorage instance', () {
      // Arrange & Act
      final storage = FirebaseService.storage;

      // Assert
      expect(storage, isA<FirebaseStorage>());
      expect(storage, equals(FirebaseStorage.instance));
    });

    test('firestore getter returns same instance on multiple calls', () {
      // Arrange & Act
      final instance1 = FirebaseService.firestore;
      final instance2 = FirebaseService.firestore;

      // Assert
      expect(identical(instance1, instance2), isTrue);
    });

    test('storage getter returns same instance on multiple calls', () {
      // Arrange & Act
      final instance1 = FirebaseService.storage;
      final instance2 = FirebaseService.storage;

      // Assert
      expect(identical(instance1, instance2), isTrue);
    });
  });
}
```

**Acceptance Criteria**:
- [ ] Test file created at correct path
- [ ] All getters tested
- [ ] Singleton behavior verified
- [ ] Test naming follows convention
- [ ] Arrange-Act-Assert pattern used

### Task 5.3: Create Firestore Repository Tests

**File**: `test/shared/data/repositories/firestore_repository_test.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';

import 'package:flutterhackthema/shared/data/repositories/firestore_repository.dart';

// テスト用のモデルクラス
class TestModel {
  const TestModel({required this.id, required this.name});

  factory TestModel.fromJson(Map<String, dynamic> json) {
    return TestModel(
      id: json['id'] as String,
      name: json['name'] as String,
    );
  }

  final String id;
  final String name;

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
    };
  }
}

// テスト用のリポジトリ実装
class TestRepository extends FirestoreRepository<TestModel> {
  TestRepository(this._firestore);

  final FirebaseFirestore _firestore;

  @override
  String get collectionPath => 'test_collection';

  @override
  CollectionReference<Map<String, dynamic>> get collection {
    return _firestore.collection(collectionPath);
  }

  @override
  TestModel fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data()!;
    return TestModel.fromJson(data);
  }

  @override
  Map<String, dynamic> toFirestore(TestModel model) {
    return model.toJson();
  }
}

void main() {
  group('FirestoreRepository', () {
    late FakeFirebaseFirestore fakeFirestore;
    late TestRepository repository;

    setUp(() {
      fakeFirestore = FakeFirebaseFirestore();
      repository = TestRepository(fakeFirestore);
    });

    test('collectionPath returns correct path', () {
      expect(repository.collectionPath, equals('test_collection'));
    });

    test('getById returns model when document exists', () async {
      // Arrange
      const testModel = TestModel(id: 'test_id', name: 'Test Name');
      await repository.collection.doc('test_id').set(testModel.toJson());

      // Act
      final result = await repository.getById('test_id');

      // Assert
      expect(result, isNotNull);
      expect(result!.id, equals('test_id'));
      expect(result.name, equals('Test Name'));
    });

    test('getById returns null when document does not exist', () async {
      // Act
      final result = await repository.getById('nonexistent_id');

      // Assert
      expect(result, isNull);
    });

    test('getAll returns all documents', () async {
      // Arrange
      const model1 = TestModel(id: '1', name: 'Name 1');
      const model2 = TestModel(id: '2', name: 'Name 2');
      await repository.collection.doc('1').set(model1.toJson());
      await repository.collection.doc('2').set(model2.toJson());

      // Act
      final results = await repository.getAll();

      // Assert
      expect(results, hasLength(2));
      expect(results[0].id, equals('1'));
      expect(results[1].id, equals('2'));
    });

    test('getAll returns empty list when no documents', () async {
      // Act
      final results = await repository.getAll();

      // Assert
      expect(results, isEmpty);
    });

    test('create adds document and returns ID', () async {
      // Arrange
      const model = TestModel(id: 'test_id', name: 'Test Name');

      // Act
      final docId = await repository.create(model);

      // Assert
      expect(docId, isNotEmpty);
      final doc = await repository.collection.doc(docId).get();
      expect(doc.exists, isTrue);
    });

    test('createWithId creates document with specified ID', () async {
      // Arrange
      const model = TestModel(id: 'custom_id', name: 'Test Name');

      // Act
      await repository.createWithId('custom_id', model);

      // Assert
      final doc = await repository.collection.doc('custom_id').get();
      expect(doc.exists, isTrue);
      expect(doc.data()!['id'], equals('custom_id'));
    });

    test('update modifies existing document', () async {
      // Arrange
      const originalModel = TestModel(id: 'test_id', name: 'Original Name');
      await repository.collection.doc('test_id').set(originalModel.toJson());
      const updatedModel = TestModel(id: 'test_id', name: 'Updated Name');

      // Act
      await repository.update('test_id', updatedModel);

      // Assert
      final doc = await repository.collection.doc('test_id').get();
      expect(doc.data()!['name'], equals('Updated Name'));
    });

    test('delete removes document', () async {
      // Arrange
      const model = TestModel(id: 'test_id', name: 'Test Name');
      await repository.collection.doc('test_id').set(model.toJson());

      // Act
      await repository.delete('test_id');

      // Assert
      final doc = await repository.collection.doc('test_id').get();
      expect(doc.exists, isFalse);
    });
  });
}
```

**Acceptance Criteria**:
- [ ] Test file created at correct path
- [ ] Test model and repository created
- [ ] All CRUD operations tested
- [ ] Edge cases covered (null, empty)
- [ ] fake_cloud_firestore used for mocking
- [ ] Test naming follows convention

### Task 5.4: Create Storage Repository Tests

**File**: `test/shared/data/repositories/storage_repository_test.dart`

**Action**: CREATE

**Full Implementation**:
```dart
import 'dart:typed_data';
import 'package:flutter_test/flutter_test.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:firebase_storage_mocks/firebase_storage_mocks.dart';

import 'package:flutterhackthema/shared/data/repositories/storage_repository.dart';

// テスト用のリポジトリ実装
class TestStorageRepository extends StorageRepository {
  TestStorageRepository(this._storage);

  final FirebaseStorage _storage;

  @override
  String get basePath => 'test_files';

  @override
  Reference get storageRef {
    return _storage.ref().child(basePath);
  }
}

void main() {
  group('StorageRepository', () {
    late MockFirebaseStorage mockStorage;
    late TestStorageRepository repository;

    setUp(() {
      mockStorage = MockFirebaseStorage();
      repository = TestStorageRepository(mockStorage);
    });

    test('basePath returns correct path', () {
      expect(repository.basePath, equals('test_files'));
    });

    test('uploadFile uploads data and returns URL', () async {
      // Arrange
      final testData = Uint8List.fromList([1, 2, 3, 4, 5]);
      const path = 'test.jpg';
      const contentType = 'image/jpeg';

      // Act
      final url = await repository.uploadFile(testData, path, contentType);

      // Assert
      expect(url, isNotEmpty);
      expect(url, contains('test.jpg'));
    });

    test('downloadFile retrieves uploaded data', () async {
      // Arrange
      final testData = Uint8List.fromList([1, 2, 3, 4, 5]);
      const path = 'test.jpg';
      await repository.uploadFile(testData, path, 'image/jpeg');

      // Act
      final downloadedData = await repository.downloadFile(path);

      // Assert
      expect(downloadedData, isNotNull);
      expect(downloadedData, equals(testData));
    });

    test('deleteFile removes file', () async {
      // Arrange
      final testData = Uint8List.fromList([1, 2, 3, 4, 5]);
      const path = 'test.jpg';
      await repository.uploadFile(testData, path, 'image/jpeg');

      // Act
      await repository.deleteFile(path);

      // Assert
      final exists = await repository.fileExists(path);
      expect(exists, isFalse);
    });

    test('fileExists returns true for existing file', () async {
      // Arrange
      final testData = Uint8List.fromList([1, 2, 3, 4, 5]);
      const path = 'test.jpg';
      await repository.uploadFile(testData, path, 'image/jpeg');

      // Act
      final exists = await repository.fileExists(path);

      // Assert
      expect(exists, isTrue);
    });

    test('fileExists returns false for non-existing file', () async {
      // Act
      final exists = await repository.fileExists('nonexistent.jpg');

      // Assert
      expect(exists, isFalse);
    });

    test('getDownloadUrl returns valid URL', () async {
      // Arrange
      final testData = Uint8List.fromList([1, 2, 3, 4, 5]);
      const path = 'test.jpg';
      await repository.uploadFile(testData, path, 'image/jpeg');

      // Act
      final url = await repository.getDownloadUrl(path);

      // Assert
      expect(url, isNotEmpty);
      expect(url, contains('test.jpg'));
    });
  });
}
```

**Acceptance Criteria**:
- [ ] Test file created at correct path
- [ ] Test repository created
- [ ] Upload, download, delete tested
- [ ] File existence check tested
- [ ] Download URL getter tested
- [ ] firebase_storage_mocks used for mocking
- [ ] Test naming follows convention

### Task 5.5: Run All Tests

**Commands**:
```bash
# Run all tests
fvm flutter test

# Run with coverage
fvm flutter test --coverage

# View coverage report
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

**Acceptance Criteria**:
- [ ] All tests pass
- [ ] Coverage ≥ 80% for Shared layer Firebase code
- [ ] No test failures or errors

---

## File Change Summary

### Files to CREATE (8 files)

**Production Code** (3 files):
1. `lib/firebase_options.dart` (auto-generated by FlutterFire CLI)
2. `lib/shared/service/firebase_service.dart`
3. `lib/shared/data/repositories/firestore_repository.dart`
4. `lib/shared/data/repositories/storage_repository.dart`

**Configuration** (2 files):
5. `firestore.rules` (project root)
6. `storage.rules` (project root)

**Tests** (3 files):
7. `test/shared/service/firebase_service_test.dart`
8. `test/shared/data/repositories/firestore_repository_test.dart`
9. `test/shared/data/repositories/storage_repository_test.dart`

### Files to MODIFY (2 files)

1. `pubspec.yaml` - Add Firebase dependencies and test dependencies
2. `lib/main.dart` - Add Firebase initialization

### Files to DELETE (1 file)

1. `lib/shared/service/.gitkeep` - Placeholder no longer needed

---

## Quality Gates

All quality gates MUST pass before marking implementation complete:

### 1. Static Analysis

```bash
fvm flutter analyze
```

**Acceptance Criteria**:
- [ ] Zero errors
- [ ] Zero warnings (or only acceptable warnings)
- [ ] No linter violations

### 2. Code Formatting

```bash
dart format --set-exit-if-changed .
```

**Acceptance Criteria**:
- [ ] All files formatted correctly
- [ ] No formatting changes needed

### 3. Code Generation

```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

**Acceptance Criteria**:
- [ ] `lib/firebase_options.dart` generated successfully
- [ ] No code generation errors

### 4. Test Execution

```bash
fvm flutter test
```

**Acceptance Criteria**:
- [ ] All tests pass
- [ ] No test failures
- [ ] No test errors

### 5. Test Coverage

```bash
fvm flutter test --coverage
```

**Acceptance Criteria**:
- [ ] Coverage ≥ 80% for Shared layer Firebase code
- [ ] All critical paths covered

### 6. Firebase Deployment

```bash
firebase deploy --only firestore:rules,storage:rules
```

**Acceptance Criteria**:
- [ ] Firestore rules deployed
- [ ] Storage rules deployed
- [ ] No deployment errors

---

## Risk Analysis and Mitigation

### Risk Matrix

| Risk | Probability | Impact | Severity | Mitigation |
|------|-------------|--------|----------|------------|
| FlutterFire CLI config fails | Low | High | Medium | Manual configuration fallback |
| Firebase initialization error | Low | High | Medium | Try-catch with error logging |
| Dependency conflicts | Low | Medium | Low | Use latest compatible versions |
| Test coverage insufficient | Medium | Medium | Medium | Write tests alongside code |
| Security rules too permissive | Medium | High | High | Start restrictive, test thoroughly |
| Architecture violation | Low | High | Medium | Code review and verification |

### Detailed Mitigations

#### 1. FlutterFire CLI Configuration Failure

**Risk**: FlutterFire CLI may fail to configure project

**Mitigation**:
- Document manual configuration steps
- Provide fallback web/index.html configuration
- Test on multiple environments

**Fallback Plan**:
```html
<!-- Manual Firebase SDK configuration -->
<script src="https://www.gstatic.com/firebasejs/10.x.x/firebase-app-compat.js"></script>
<script>
  const firebaseConfig = {
    apiKey: "...",
    projectId: "myaku-haiku",
    // ... other config
  };
  firebase.initializeApp(firebaseConfig);
</script>
```

#### 2. Firebase Initialization Error

**Risk**: Firebase may fail to initialize on app startup

**Mitigation**:
- Wrap Firebase.initializeApp() in try-catch
- Log errors to console in development
- Display error message to user in production
- Allow app to continue (graceful degradation)

**Implementation**:
```dart
try {
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
} catch (e, stackTrace) {
  debugPrint('Firebase initialization error: $e');
  // TODO: Show error page in production
}
```

#### 3. Dependency Conflicts

**Risk**: Firebase packages may conflict with existing dependencies

**Mitigation**:
- Use latest compatible versions
- Run `fvm flutter pub get` after adding dependencies
- Check for version conflicts in output
- Use `fvm flutter pub upgrade` if needed

**Verification**:
```bash
fvm flutter pub get
# Check output for conflicts
```

#### 4. Test Coverage Insufficient

**Risk**: Test coverage may fall below 80% target

**Mitigation**:
- Write tests alongside implementation
- Run coverage after each phase
- Identify untested code paths
- Add tests for edge cases

**Monitoring**:
```bash
fvm flutter test --coverage
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

#### 5. Security Rules Too Permissive

**Risk**: Security rules may allow unintended access

**Mitigation**:
- Start with restrictive rules (block all by default)
- Gradually open access as needed
- Test rules with Firebase Emulator
- Review rules before deployment
- Document rule decisions

**Testing**:
```bash
# Install Firebase Emulator
firebase init emulators

# Run emulator
firebase emulators:start

# Test rules
# ... run app against emulator
```

#### 6. Architecture Violation

**Risk**: Firebase code may be placed in wrong layer

**Mitigation**:
- Follow strict placement guidelines:
  - App Layer: Initialization only (main.dart)
  - Shared Layer: Services and base repositories
  - Feature Layer: Specific implementations (future work)
- Code review before merging
- Architecture compliance checklist

**Verification Checklist**:
- [ ] No Firebase imports in Feature layer (except future repositories)
- [ ] No business logic in App layer
- [ ] All Firebase services in Shared layer
- [ ] No Feature → Feature dependencies

---

## Testing Strategy

### Unit Testing

**Scope**: All Shared layer Firebase code

**Tools**:
- `flutter_test` - Flutter testing framework
- `fake_cloud_firestore` - Mock Firestore
- `firebase_storage_mocks` - Mock Storage
- `mockito` - General mocking (if needed)

**Coverage Target**: ≥ 80%

**Test Cases**:

1. **FirebaseService**:
   - ✓ firestore getter returns correct instance
   - ✓ storage getter returns correct instance
   - ✓ Singleton behavior verified

2. **FirestoreRepository**:
   - ✓ getById returns model when exists
   - ✓ getById returns null when not exists
   - ✓ getAll returns all documents
   - ✓ getAll returns empty list when no documents
   - ✓ create adds document and returns ID
   - ✓ createWithId creates with custom ID
   - ✓ update modifies existing document
   - ✓ delete removes document

3. **StorageRepository**:
   - ✓ uploadFile uploads and returns URL
   - ✓ downloadFile retrieves data
   - ✓ deleteFile removes file
   - ✓ fileExists returns true for existing file
   - ✓ fileExists returns false for non-existing file
   - ✓ getDownloadUrl returns valid URL

### Integration Testing

**Scope**: Firebase initialization

**Test Cases**:
- ✓ App starts without errors
- ✓ Firebase initializes successfully
- ✓ Firestore instance accessible
- ✓ Storage instance accessible

**Manual Testing**:
1. Run app: `fvm flutter run -d chrome`
2. Check console for initialization logs
3. Verify no Firebase errors
4. Open DevTools network tab
5. Verify Firebase SDK loaded

### Security Rules Testing

**Scope**: Firestore and Storage rules

**Tools**:
- Firebase Emulator Suite
- Firebase Console Rules Simulator

**Test Cases**:

1. **Firestore Rules**:
   - ✓ Anyone can read posts
   - ✓ Create with valid data succeeds
   - ✓ Create with invalid data fails
   - ✓ Update operation blocked
   - ✓ Delete operation blocked

2. **Storage Rules**:
   - ✓ Anyone can read images
   - ✓ Upload valid image succeeds
   - ✓ Upload oversized file fails
   - ✓ Upload non-image file fails
   - ✓ Update operation blocked
   - ✓ Delete operation blocked

---

## Implementation Checklist

### Pre-Implementation

- [ ] Read investigation report thoroughly
- [ ] Verify architecture requirements
- [ ] Review coding style guide
- [ ] Create feature branch (already done: feature/firebase-setup)
- [ ] Ensure Firebase project created (myaku-haiku)

### Phase 1: Dependencies & Configuration

- [ ] Add Firebase dependencies to pubspec.yaml
- [ ] Run `fvm flutter pub get`
- [ ] Install FlutterFire CLI
- [ ] Run `flutterfire configure --project=myaku-haiku`
- [ ] Verify `lib/firebase_options.dart` generated
- [ ] Verify no dependency conflicts

### Phase 2: Firebase Initialization

- [ ] Update `lib/main.dart` with imports
- [ ] Make main() async
- [ ] Add WidgetsFlutterBinding.ensureInitialized()
- [ ] Add Firebase.initializeApp() with try-catch
- [ ] Update Japanese documentation
- [ ] Add TODO comment for production error handling
- [ ] Test app runs without errors

### Phase 3: Shared Layer Services

- [ ] Create `lib/shared/service/firebase_service.dart`
- [ ] Implement firestore getter
- [ ] Implement storage getter
- [ ] Add comprehensive documentation
- [ ] Delete `lib/shared/service/.gitkeep`
- [ ] Create `lib/shared/data/repositories/firestore_repository.dart`
- [ ] Implement abstract base class
- [ ] Implement CRUD operations
- [ ] Add comprehensive documentation
- [ ] Create `lib/shared/data/repositories/storage_repository.dart`
- [ ] Implement abstract base class
- [ ] Implement upload/download/delete operations
- [ ] Add comprehensive documentation

### Phase 4: Security Rules

- [ ] Create `firestore.rules` in project root
- [ ] Implement posts collection rules
- [ ] Add validation for create operations
- [ ] Block update and delete operations
- [ ] Add Japanese comments
- [ ] Create `storage.rules` in project root
- [ ] Implement posts images rules
- [ ] Add size and type validation
- [ ] Block update and delete operations
- [ ] Add Japanese comments
- [ ] Deploy Firestore rules: `firebase deploy --only firestore:rules`
- [ ] Deploy Storage rules: `firebase deploy --only storage:rules`
- [ ] Verify deployment in Firebase Console

### Phase 5: Testing

- [ ] Add testing dependencies to pubspec.yaml
- [ ] Run `fvm flutter pub get`
- [ ] Create `test/shared/service/firebase_service_test.dart`
- [ ] Implement all test cases
- [ ] Create `test/shared/data/repositories/firestore_repository_test.dart`
- [ ] Implement all test cases
- [ ] Create `test/shared/data/repositories/storage_repository_test.dart`
- [ ] Implement all test cases
- [ ] Run all tests: `fvm flutter test`
- [ ] Verify all tests pass
- [ ] Run coverage: `fvm flutter test --coverage`
- [ ] Verify coverage ≥ 80%

### Quality Gates

- [ ] Run `fvm flutter analyze` - zero errors
- [ ] Run `dart format --set-exit-if-changed .` - no changes needed
- [ ] Run `fvm flutter test` - all tests pass
- [ ] Run `fvm flutter test --coverage` - coverage ≥ 80%
- [ ] Verify Firebase rules deployed
- [ ] Manual test: app runs without errors
- [ ] Manual test: Firebase initialized successfully

### Final Steps

- [ ] Review all created files
- [ ] Verify architecture compliance
- [ ] Verify coding style compliance
- [ ] Commit changes with Angular-style message
- [ ] Push to remote branch
- [ ] Create pull request (if needed)
- [ ] Update Issue #7 checklist

---

## Architecture Compliance Verification

### Three-Layer Verification

**App Layer** (`lib/app/`):
- [ ] `lib/main.dart` contains ONLY Firebase initialization
- [ ] NO business logic in App layer
- [ ] NO direct Firestore/Storage usage in App layer

**Shared Layer** (`lib/shared/`):
- [ ] `lib/shared/service/firebase_service.dart` provides Firebase instances
- [ ] `lib/shared/data/repositories/firestore_repository.dart` provides base Firestore operations
- [ ] `lib/shared/data/repositories/storage_repository.dart` provides base Storage operations
- [ ] NO dependencies on App or Feature layers
- [ ] All Firebase logic centralized in Shared layer

**Feature Layer** (`lib/features/`):
- [ ] NO changes to Feature layer in this implementation
- [ ] Future repositories will extend Shared base classes
- [ ] NO direct Firebase imports in Feature layer (future work will use Shared)

### Dependency Flow Verification

- [ ] App → Shared (main.dart imports firebase_options.dart) ✅
- [ ] Shared → (no dependencies) ✅
- [ ] NO Feature → Feature ✅
- [ ] NO Shared → App ✅
- [ ] NO Shared → Feature ✅

---

## Coding Style Compliance

### Naming Conventions

- [ ] Files: snake_case (`firebase_service.dart`, `firestore_repository.dart`)
- [ ] Classes: PascalCase (`FirebaseService`, `FirestoreRepository`)
- [ ] Variables/Functions: camelCase (`firestore`, `getById()`)
- [ ] Constants: lowerCamelCase (not applicable in this implementation)
- [ ] Private members: prefix with `_` (`_firestore`, if needed)
- [ ] Booleans: start with is/has/can/should (not applicable)

### Documentation

- [ ] All public APIs have `///` doc comments
- [ ] Documentation in Japanese
- [ ] Include parameter descriptions
- [ ] Include return value descriptions
- [ ] Include throws clauses for exceptions
- [ ] Include usage examples where helpful

### Code Quality

- [ ] Explicit type annotations (no `var` or `dynamic`)
- [ ] `const` constructors used where possible
- [ ] Proper import ordering:
  1. Dart SDK
  2. Flutter SDK
  3. External packages
  4. Project - shared
  5. Project - features
  6. Relative imports
- [ ] No `print()` statements (use `debugPrint()`)
- [ ] No code duplication
- [ ] Functions < 100 lines
- [ ] No magic numbers (use constants)

---

## Post-Implementation Verification

### Functionality Verification

**Firebase Initialization**:
- [ ] App starts without errors
- [ ] Firebase initializes successfully
- [ ] No console errors related to Firebase
- [ ] DevTools shows Firebase SDK loaded

**Firestore Access**:
- [ ] FirebaseService.firestore returns instance
- [ ] No errors accessing Firestore
- [ ] Singleton behavior confirmed

**Storage Access**:
- [ ] FirebaseService.storage returns instance
- [ ] No errors accessing Storage
- [ ] Singleton behavior confirmed

**Security Rules**:
- [ ] Firestore rules visible in Firebase Console
- [ ] Storage rules visible in Firebase Console
- [ ] Rules match implementation

### Test Verification

- [ ] All unit tests pass
- [ ] Test coverage ≥ 80% for Shared layer
- [ ] No test failures or errors
- [ ] Coverage report generated successfully

### Documentation Verification

- [ ] All public APIs documented
- [ ] Japanese documentation clear and accurate
- [ ] Usage examples provided
- [ ] TODO comments added for future work

---

## Success Criteria

Implementation is considered successful when:

1. **Dependencies**:
   - ✅ All Firebase packages added to pubspec.yaml
   - ✅ FlutterFire CLI configured successfully
   - ✅ firebase_options.dart generated

2. **Initialization**:
   - ✅ Firebase initializes in main.dart without errors
   - ✅ Error handling implemented with try-catch
   - ✅ App runs successfully on Web

3. **Shared Layer**:
   - ✅ FirebaseService created with firestore and storage getters
   - ✅ FirestoreRepository base class created with CRUD operations
   - ✅ StorageRepository base class created with file operations
   - ✅ All code properly documented in Japanese

4. **Security Rules**:
   - ✅ firestore.rules created and deployed
   - ✅ storage.rules created and deployed
   - ✅ Rules visible in Firebase Console

5. **Testing**:
   - ✅ All unit tests pass
   - ✅ Test coverage ≥ 80% for Firebase code
   - ✅ No test failures or errors

6. **Quality**:
   - ✅ Zero `fvm flutter analyze` errors
   - ✅ Code formatted correctly
   - ✅ Architecture compliance verified
   - ✅ Coding style compliance verified

7. **Issue Resolution**:
   - ✅ All tasks in Issue #7 completed:
     - [x] Firebase プロジェクト作成
     - [x] Flutter Web 用の Firebase 設定
     - [x] pubspec.yaml に依存関係追加
     - [x] Firebase 初期化コード（main.dart）
     - [x] Firestore セキュリティルール設定
     - [x] Storage セキュリティルール設定

---

## Next Steps After Implementation

### Immediate Next Steps

1. **Code Review**:
   - Request code review from team
   - Address review comments
   - Verify architecture compliance

2. **Documentation Update**:
   - Update CLAUDE.md with Firebase integration notes
   - Document Firebase configuration for team
   - Add Firebase setup to README if needed

3. **Issue Management**:
   - Close Issue #7
   - Link to pull request
   - Update project board

### Future Enhancements (Not in Scope)

1. **Feature Layer Implementation** (Issue #8+):
   - Create PostRepository extending FirestoreRepository
   - Create ImageStorageRepository extending StorageRepository
   - Implement Riverpod providers for Firebase data

2. **Firebase Emulator Setup**:
   - Configure Firebase Emulator Suite
   - Update testing to use emulator
   - Document emulator usage

3. **Error Handling Improvements**:
   - Create custom Firebase exception classes
   - Implement user-friendly error messages
   - Add retry logic for network failures

4. **Performance Optimization**:
   - Implement Firestore query optimization
   - Add caching for frequently accessed data
   - Optimize image upload compression

5. **Security Enhancements**:
   - Add user authentication (if required)
   - Implement rate limiting in rules
   - Add data validation on client side

---

## References

### Official Documentation

- [FlutterFire Documentation](https://firebase.flutter.dev/)
- [Firebase Web SDK Setup](https://firebase.google.com/docs/web/setup)
- [Firestore Security Rules](https://firebase.google.com/docs/firestore/security/get-started)
- [Storage Security Rules](https://firebase.google.com/docs/storage/security/start)
- [Firebase Emulator Suite](https://firebase.google.com/docs/emulator-suite)

### Project Documentation

- [Investigation Report](docs/investigate/investigate_20251129_170813.md)
- [Architecture Guidelines](docs/ARCHITECTURE.md)
- [Coding Style Guide](docs/STYLE_GUIDE.md)
- [Requirements](docs/REQUIREMENTS.md)
- [Claude Code Instructions](CLAUDE.md)

### Related Issues

- [Issue #7 - Firebase プロジェクトセットアップ](https://github.com/MoguMoguDesign/flutter--hackathon-thema/issues/7) - Current
- Issue #10 - SharedPreferences による永続化 (Referenced in code)

### External Resources

- [Effective Dart](https://dart.dev/guides/language/effective-dart)
- [Flutter Testing Documentation](https://flutter.dev/docs/testing)
- [Riverpod Documentation](https://riverpod.dev/)

---

**Plan created**: 2025-11-29 17:12:22
**Based on**: Investigation Report (investigate_20251129_170813.md)
**Branch**: feature/firebase-setup
**Estimated effort**: 1 hour
**Next phase**: IMPLEMENT
