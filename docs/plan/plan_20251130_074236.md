# Implementation Plan: Issue #12 - Posts List Screen with Firestore Integration

## Plan Metadata

- **Issue**: #12 - みんなの投稿一覧画面の実装
- **Investigation**: `docs/investigate/investigate_20251130_073758.md`
- **Branch**: `feature/issue-12-posts-list`
- **Created**: 2025-11-30 07:42:36
- **Architecture Layer**: Feature (posts)
- **Estimated Effort**: 5-6 hours total (Phase 1: 3h, Phase 2: 2-3h)

## Executive Summary

### Current Status
- ✅ UI Implementation: PostsPage and PostCard widgets complete
- ✅ Routing: `/posts` and `/posts/:postId` configured
- ❌ Data Layer: Repository and Providers missing
- ❌ Firestore Integration: Using mock data
- ❌ Testing: No tests exist

### Implementation Strategy
**Two-Phase Incremental Approach** (Recommended)

**Phase 1 (MUST HAVE)**: Core Firestore Integration
- Post model refactoring with @JsonSerializable
- PostRepository implementation
- Riverpod providers (@riverpod annotation)
- PostsPage refactoring for Firestore data
- Loading/Error states
- Basic unit tests

**Phase 2 (SHOULD HAVE)**: Enhanced Features
- Infinite scroll implementation
- Comprehensive widget tests
- Performance optimization
- Provider tests

### Success Criteria
- [ ] PostsPage displays realtime Firestore data
- [ ] Loading states show during data fetch
- [ ] Error states display on Firestore failures
- [ ] FAB navigation to haiku creation works
- [ ] Post cards navigate to detail page
- [ ] All unit tests pass
- [ ] Static analysis passes (0 errors)
- [ ] Code generation complete

---

## Architecture Compliance Verification

### Three-Layer Architecture
```
App Layer
  └─> app_router/routes.dart (already configured ✅)
      ↓
Feature Layer (posts)
  ├─> data/
  │   ├─> models/post.dart (REFACTOR NEEDED ⚠️)
  │   └─> repositories/post_repository.dart (NEW ❌)
  ├─> presentation/
  │   ├─> pages/posts_page.dart (REFACTOR NEEDED ⚠️)
  │   ├─> widgets/post_card.dart (COMPLETE ✅)
  │   └─> providers/posts_provider.dart (NEW ❌)
      ↓
Shared Layer
  ├─> data/repositories/firestore_repository.dart (EXISTS ✅)
  └─> service/firebase_service.dart (EXISTS ✅)
```

### Dependency Rules Compliance
- ✅ Posts feature only depends on Shared layer
- ✅ No Feature-to-Feature dependencies
- ✅ Unidirectional dependency flow

---

## Phase 1: Core Firestore Integration (3 hours)

### Phase 1 Overview

| Task | File | Type | Estimated Time | Priority |
|------|------|------|---------------|----------|
| 1.1 | Post model refactoring | MODIFY | 30 min | HIGH |
| 1.2 | Code generation | RUN CMD | 5 min | HIGH |
| 1.3 | PostRepository implementation | NEW | 45 min | HIGH |
| 1.4 | Providers implementation | NEW | 30 min | HIGH |
| 1.5 | PostsPage refactoring | MODIFY | 45 min | HIGH |
| 1.6 | Post model tests | NEW | 30 min | HIGH |
| 1.7 | PostRepository tests | NEW | 1 hour | HIGH |
| 1.8 | Verification | RUN CMD | 15 min | HIGH |
| **TOTAL** | | | **~4.5 hours** | |

---

### Task 1.1: Refactor Post Model

**File**: `lib/features/posts/data/models/post.dart`
**Type**: MODIFY
**Estimated Time**: 30 minutes
**Priority**: HIGH

#### Current Implementation Issues
- Not using @JsonSerializable (project standard)
- No code generation setup
- Missing fromJson/toJson methods
- Haiku stored as single string (inconsistent with HaikuModel)

#### Implementation Steps

**Step 1.1.1**: Add required imports and annotations
```dart
// Add at top of file
import 'package:json_annotation/json_annotation.dart';

part 'post.g.dart';
```

**Step 1.1.2**: Add @JsonSerializable annotation
```dart
/// 投稿データモデル
///
/// Firestoreに保存する俳句×画像の投稿情報を保持する
@JsonSerializable()
class Post {
  // existing fields...
}
```

**Step 1.1.3**: Update constructor to use `const`
```dart
const Post({
  required this.id,
  required this.nickname,
  required this.haiku,
  required this.imageUrl,
  required this.createdAt,
  this.likeCount = 0,
});
```

**Step 1.1.4**: Add fromJson factory
```dart
/// FirestoreドキュメントからPostモデルを生成
factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);
```

**Step 1.1.5**: Add toJson method
```dart
/// PostモデルをFirestoreドキュメントに変換
Map<String, dynamic> toJson() => _$PostToJson(this);
```

**Step 1.1.6**: Remove mockPosts() method
- This will be replaced by Firestore data

#### Code Pattern Reference
Follow `lib/features/haiku/data/models/haiku_model.dart` pattern

#### Acceptance Criteria
- [ ] @JsonSerializable annotation added
- [ ] part directive for .g.dart added
- [ ] fromJson factory implemented
- [ ] toJson method implemented
- [ ] const constructor used
- [ ] mockPosts() removed
- [ ] Documentation comments in Japanese

---

### Task 1.2: Code Generation

**Type**: COMMAND
**Estimated Time**: 5 minutes
**Priority**: HIGH

#### Commands to Execute

**Step 1.2.1**: Run build_runner
```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

**Step 1.2.2**: Verify generated file
```bash
ls -la lib/features/posts/data/models/post.g.dart
```

#### Expected Output
- `post.g.dart` file created
- Contains `_$PostFromJson` and `_$PostToJson` functions

#### Acceptance Criteria
- [ ] post.g.dart generated successfully
- [ ] No build errors
- [ ] Generated code compiles

---

### Task 1.3: Implement PostRepository

**File**: `lib/features/posts/data/repositories/post_repository.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 45 minutes
**Priority**: HIGH

#### Implementation Steps

**Step 1.3.1**: Create file with header
```dart
// FLUTTER HACKATHON THEMA - DO NOT DELETE THIS FILE
// This file is managed by AI development rules (CLAUDE.md)
//
// Architecture: Three-Layer (App → Feature → Shared)
// State Management: hooks_riverpod 3.x with @riverpod annotation (MANDATORY)
// Router: go_router 16.x (MANDATORY)
// Code Generation: build_runner, riverpod_generator, freezed (REQUIRED)
// Testing: Comprehensive coverage required
//
// Development Rules:
// - Use @riverpod annotation for all providers
// - Use HookConsumerWidget when using hooks
// - Documentation comments in Japanese (///)
// - Follow three-layer architecture strictly
// - No direct Feature-to-Feature dependencies
// - All changes must pass: analyze, format, test
//
```

**Step 1.3.2**: Add imports
```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:logger/logger.dart';

import 'package:flutterhackthema/shared/data/repositories/firestore_repository.dart';
import '../models/post.dart';
```

**Step 1.3.3**: Create repository class
```dart
/// 投稿データのFirestoreリポジトリ
///
/// Firestoreの`posts`コレクションに対するCRUD操作を提供します
/// [FirestoreRepository]を継承し、投稿特有のロジックを実装します
class PostRepository extends FirestoreRepository<Post> {
  /// 投稿リポジトリを作成する
  PostRepository() : super(collectionPath: 'posts');

  final Logger _logger = Logger();

  @override
  Post fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Document data is null for post ${snapshot.id}');
    }

    // IDをデータに追加してモデルを生成
    return Post.fromJson({...data, 'id': snapshot.id});
  }

  @override
  Map<String, dynamic> toFirestore(Post data) {
    final json = data.toJson();

    // Firestoreに保存する際はIDを除外
    // (IDはドキュメントIDとして自動設定される)
    json.remove('id');

    return json;
  }

  /// 投稿を作成時刻の降順でリアルタイム監視
  ///
  /// Returns: 投稿のリアルタイムストリーム（新しい順）
  Stream<List<Post>> watchAllPosts() {
    _logger.d('Watching all posts with createdAt desc order');
    return watchAll(
      query: collection.orderBy('createdAt', descending: true),
    );
  }
}
```

#### Code Pattern Reference
Follow `lib/features/haiku/data/repositories/haiku_repository.dart` pattern

#### Firestore Collection Schema
```
posts/
  {postId}/
    nickname: string
    haiku: string
    imageUrl: string
    createdAt: timestamp
    likeCount: number
```

#### Acceptance Criteria
- [ ] Extends FirestoreRepository<Post>
- [ ] Collection path set to 'posts'
- [ ] fromFirestore() implemented
- [ ] toFirestore() implemented
- [ ] watchAllPosts() with ordering
- [ ] Logger for debugging
- [ ] Documentation comments in Japanese
- [ ] Follows project header template

---

### Task 1.4: Implement Riverpod Providers

**File**: `lib/features/posts/presentation/providers/posts_provider.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 30 minutes
**Priority**: HIGH

#### Implementation Steps

**Step 1.4.1**: Create file with header (same as 1.3.1)

**Step 1.4.2**: Add imports
```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../data/models/post.dart';
import '../../data/repositories/post_repository.dart';

part 'posts_provider.g.dart';
```

**Step 1.4.3**: Create repository provider
```dart
/// PostRepositoryのプロバイダー
///
/// [PostRepository]のインスタンスを提供します
@riverpod
PostRepository postRepository(Ref ref) {
  return PostRepository();
}
```

**Step 1.4.4**: Create stream provider
```dart
/// 投稿一覧のリアルタイムストリームプロバイダー
///
/// Firestoreから投稿を作成日時の降順でリアルタイム取得します
/// PostsPageで使用して投稿一覧を表示します
@riverpod
Stream<List<Post>> postsStream(Ref ref) {
  final repository = ref.watch(postRepositoryProvider);
  return repository.watchAllPosts();
}
```

**Step 1.4.5**: Run code generation
```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

#### Code Pattern Reference
Follow `lib/features/haiku/presentation/providers/haiku_provider.dart` pattern

#### Acceptance Criteria
- [ ] @riverpod annotation used
- [ ] part directive for .g.dart added
- [ ] Repository provider implemented
- [ ] Stream provider implemented
- [ ] Documentation comments in Japanese
- [ ] posts_provider.g.dart generated
- [ ] No build errors

---

### Task 1.5: Refactor PostsPage for Firestore

**File**: `lib/features/posts/presentation/pages/posts_page.dart`
**Type**: MODIFY
**Estimated Time**: 45 minutes
**Priority**: HIGH

#### Current Implementation Issues
- StatelessWidget (needs state management)
- Using Post.mockPosts() hardcoded data
- No loading/error states
- No Firestore integration

#### Implementation Steps

**Step 1.5.1**: Add imports
```dart
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../providers/posts_provider.dart';
```

**Step 1.5.2**: Change to HookConsumerWidget
```dart
/// みんなの投稿一覧画面
///
/// Firestoreから投稿をリアルタイム取得して
/// Staggered Grid レイアウトで表示します
class PostsPage extends HookConsumerWidget {
  const PostsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // postsStreamを監視
    final postsAsync = ref.watch(postsStreamProvider);

    return AppScaffoldWithBackground(
      body: SafeArea(
        child: postsAsync.when(
          // ローディング状態
          loading: () => const CustomScrollView(
            slivers: [
              AppSliverHeader(),
              SliverFillRemaining(
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              ),
            ],
          ),
          // エラー状態
          error: (error, stack) => CustomScrollView(
            slivers: [
              const AppSliverHeader(),
              SliverFillRemaining(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(
                        Icons.error_outline,
                        size: 48,
                        color: Colors.red,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'データの取得に失敗しました',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        error.toString(),
                        style: Theme.of(context).textTheme.bodySmall,
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          // データ取得成功
          data: (posts) => CustomScrollView(
            slivers: [
              const AppSliverHeader(),
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                sliver: _SliverStaggeredGrid(
                  posts: posts,
                  onPostTap: (post) {
                    PostDetailRoute(postId: post.id).go(context);
                  },
                ),
              ),
            ],
          ),
        ),
      ),
      floatingActionButton: /* ... existing FAB code ... */,
    );
  }
}
```

**Step 1.5.3**: Remove mock data call
- Delete `final posts = Post.mockPosts();` line

**Step 1.5.4**: Add empty state handling (optional but recommended)
```dart
data: (posts) {
  // 投稿が0件の場合
  if (posts.isEmpty) {
    return const CustomScrollView(
      slivers: [
        AppSliverHeader(),
        SliverFillRemaining(
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.inbox_outlined,
                  size: 64,
                  color: Colors.grey,
                ),
                SizedBox(height: 16),
                Text(
                  'まだ投稿がありません',
                  style: TextStyle(
                    fontSize: 16,
                    color: Colors.grey,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  // 投稿がある場合
  return CustomScrollView(
    slivers: [
      const AppSliverHeader(),
      SliverPadding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        sliver: _SliverStaggeredGrid(
          posts: posts,
          onPostTap: (post) {
            PostDetailRoute(postId: post.id).go(context);
          },
        ),
      ),
    ],
  );
},
```

#### AsyncValue.when() States
- **loading**: Show CircularProgressIndicator
- **error**: Show error message with icon
- **data**: Show posts grid or empty state

#### Acceptance Criteria
- [ ] Changed to HookConsumerWidget
- [ ] Uses ref.watch(postsStreamProvider)
- [ ] AsyncValue.when() for state handling
- [ ] Loading state with CircularProgressIndicator
- [ ] Error state with message
- [ ] Empty state for no posts
- [ ] Data state with grid
- [ ] Mock data removed
- [ ] Documentation updated

---

### Task 1.6: Post Model Unit Tests

**File**: `test/features/posts/data/models/post_test.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 30 minutes
**Priority**: HIGH

#### Implementation

```dart
import 'package:flutter_test/flutter_test.dart';

import 'package:flutterhackthema/features/posts/data/models/post.dart';

void main() {
  group('Post Model', () {
    test('fromJson creates Post correctly', () {
      // Arrange
      final json = {
        'id': 'post-123',
        'nickname': 'テストユーザー',
        'haiku': '古池や\n蛙飛び込む\n水の音',
        'imageUrl': 'https://example.com/image.jpg',
        'createdAt': DateTime(2025, 1, 1).toIso8601String(),
        'likeCount': 10,
      };

      // Act
      final post = Post.fromJson(json);

      // Assert
      expect(post.id, equals('post-123'));
      expect(post.nickname, equals('テストユーザー'));
      expect(post.haiku, contains('古池や'));
      expect(post.likeCount, equals(10));
    });

    test('toJson serializes Post correctly', () {
      // Arrange
      final post = Post(
        id: 'post-456',
        nickname: 'サンプル',
        haiku: '夏草や\n兵どもが\n夢の跡',
        imageUrl: 'https://example.com/image.jpg',
        createdAt: DateTime(2025, 1, 1),
        likeCount: 5,
      );

      // Act
      final json = post.toJson();

      // Assert
      expect(json['id'], equals('post-456'));
      expect(json['nickname'], equals('サンプル'));
      expect(json['haiku'], contains('夏草や'));
      expect(json['likeCount'], equals(5));
    });

    test('fromJson and toJson are inverse operations', () {
      // Arrange
      final original = Post(
        id: 'test-id',
        nickname: 'ユーザー',
        haiku: 'テスト俳句',
        imageUrl: 'https://example.com/test.jpg',
        createdAt: DateTime(2025, 1, 1),
        likeCount: 0,
      );

      // Act
      final json = original.toJson();
      final reconstructed = Post.fromJson(json);

      // Assert
      expect(reconstructed.id, equals(original.id));
      expect(reconstructed.nickname, equals(original.nickname));
      expect(reconstructed.haiku, equals(original.haiku));
      expect(reconstructed.likeCount, equals(original.likeCount));
    });
  });
}
```

#### Acceptance Criteria
- [ ] fromJson test passes
- [ ] toJson test passes
- [ ] Round-trip test passes
- [ ] Follows Arrange-Act-Assert pattern

---

### Task 1.7: PostRepository Unit Tests

**File**: `test/features/posts/data/repositories/post_repository_test.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 1 hour
**Priority**: HIGH

#### Implementation

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutterhackthema/features/posts/data/models/post.dart';
import 'package:flutterhackthema/features/posts/data/repositories/post_repository.dart';

/// テスト用のPostRepository (FakeFirebaseFirestoreを注入)
class TestPostRepository extends PostRepository {
  TestPostRepository({required FakeFirebaseFirestore fakeFirestore})
      : _fakeFirestore = fakeFirestore;

  final FakeFirebaseFirestore _fakeFirestore;

  @override
  FirebaseFirestore get firestore => _fakeFirestore;
}

void main() {
  group('PostRepository', () {
    late FakeFirebaseFirestore fakeFirestore;
    late TestPostRepository repository;

    setUp(() {
      fakeFirestore = FakeFirebaseFirestore();
      repository = TestPostRepository(fakeFirestore: fakeFirestore);
    });

    group('create', () {
      test('creates post with auto-generated ID', () async {
        // Arrange
        final post = Post(
          id: '', // auto-generated
          nickname: 'テストユーザー',
          haiku: '古池や\n蛙飛び込む\n水の音',
          imageUrl: 'https://example.com/image.jpg',
          createdAt: DateTime(2025, 1, 1),
        );

        // Act
        final docId = await repository.create(post);

        // Assert
        expect(docId, isNotEmpty);

        final doc = await repository.collection.doc(docId).get();
        expect(doc.exists, isTrue);
        expect(doc.data()!['nickname'], equals('テストユーザー'));
      });

      test('creates post with custom ID', () async {
        // Arrange
        const customId = 'custom-post-id';
        final post = Post(
          id: customId,
          nickname: 'カスタムユーザー',
          haiku: '閑さや\n岩にしみ入る\n蝉の声',
          imageUrl: 'https://example.com/image.jpg',
          createdAt: DateTime(2025, 1, 1),
        );

        // Act
        final docId = await repository.create(post, docId: customId);

        // Assert
        expect(docId, equals(customId));

        final doc = await repository.collection.doc(customId).get();
        expect(doc.exists, isTrue);
      });
    });

    group('read', () {
      test('reads existing post', () async {
        // Arrange
        const docId = 'test-post';
        final post = Post(
          id: docId,
          nickname: '読取テスト',
          haiku: '菜の花や\n月は東に\n日は西に',
          imageUrl: 'https://example.com/image.jpg',
          createdAt: DateTime(2025, 1, 1),
        );
        await repository.create(post, docId: docId);

        // Act
        final result = await repository.read(docId);

        // Assert
        expect(result, isNotNull);
        expect(result!.id, equals(docId));
        expect(result.nickname, equals('読取テスト'));
      });

      test('returns null for non-existent post', () async {
        // Act
        final result = await repository.read('non-existent');

        // Assert
        expect(result, isNull);
      });
    });

    group('update', () {
      test('updates existing post', () async {
        // Arrange
        const docId = 'update-test';
        final original = Post(
          id: docId,
          nickname: '元ユーザー',
          haiku: '雪とけて\n村いっぱいの\n子どもかな',
          imageUrl: 'https://example.com/original.jpg',
          createdAt: DateTime(2025, 1, 1),
        );
        await repository.create(original, docId: docId);

        final updated = Post(
          id: docId,
          nickname: '新ユーザー',
          haiku: '雪とけて\n村いっぱいの\n子どもかな',
          imageUrl: 'https://example.com/updated.jpg',
          createdAt: DateTime(2025, 1, 1),
          likeCount: 10,
        );

        // Act
        await repository.update(docId, updated);

        // Assert
        final result = await repository.read(docId);
        expect(result!.nickname, equals('新ユーザー'));
        expect(result.likeCount, equals(10));
      });
    });

    group('delete', () {
      test('deletes existing post', () async {
        // Arrange
        const docId = 'delete-test';
        final post = Post(
          id: docId,
          nickname: '削除テスト',
          haiku: '柿くへば\n鐘が鳴るなり\n法隆寺',
          imageUrl: 'https://example.com/image.jpg',
          createdAt: DateTime(2025, 1, 1),
        );
        await repository.create(post, docId: docId);

        // Act
        await repository.delete(docId);

        // Assert
        final result = await repository.read(docId);
        expect(result, isNull);
      });
    });

    group('readAll', () {
      test('returns all posts', () async {
        // Arrange
        final post1 = Post(
          id: 'post-1',
          nickname: 'ユーザー1',
          haiku: '俳句1',
          imageUrl: 'https://example.com/1.jpg',
          createdAt: DateTime(2025, 1, 1),
        );
        final post2 = Post(
          id: 'post-2',
          nickname: 'ユーザー2',
          haiku: '俳句2',
          imageUrl: 'https://example.com/2.jpg',
          createdAt: DateTime(2025, 1, 2),
        );

        await repository.create(post1, docId: 'post-1');
        await repository.create(post2, docId: 'post-2');

        // Act
        final results = await repository.readAll();

        // Assert
        expect(results, hasLength(2));
        expect(
          results.map((p) => p.nickname),
          containsAll(['ユーザー1', 'ユーザー2']),
        );
      });

      test('returns empty list when no posts exist', () async {
        // Act
        final results = await repository.readAll();

        // Assert
        expect(results, isEmpty);
      });
    });

    group('watchAllPosts', () {
      test('emits posts in descending order by createdAt', () async {
        // Arrange
        final post1 = Post(
          id: 'post-1',
          nickname: 'ユーザー1',
          haiku: '俳句1',
          imageUrl: 'https://example.com/1.jpg',
          createdAt: DateTime(2025, 1, 1),
        );
        final post2 = Post(
          id: 'post-2',
          nickname: 'ユーザー2',
          haiku: '俳句2',
          imageUrl: 'https://example.com/2.jpg',
          createdAt: DateTime(2025, 1, 3),
        );
        final post3 = Post(
          id: 'post-3',
          nickname: 'ユーザー3',
          haiku: '俳句3',
          imageUrl: 'https://example.com/3.jpg',
          createdAt: DateTime(2025, 1, 2),
        );

        await repository.create(post1, docId: 'post-1');
        await repository.create(post2, docId: 'post-2');
        await repository.create(post3, docId: 'post-3');

        // Act
        final stream = repository.watchAllPosts();

        // Assert
        await expectLater(
          stream,
          emits((List<Post> posts) {
            expect(posts, hasLength(3));
            // 降順: post2 (Jan 3) > post3 (Jan 2) > post1 (Jan 1)
            expect(posts[0].id, equals('post-2'));
            expect(posts[1].id, equals('post-3'));
            expect(posts[2].id, equals('post-1'));
            return true;
          }),
        );
      });
    });
  });
}
```

#### Test Coverage
- [ ] create() with auto-generated ID
- [ ] create() with custom ID
- [ ] read() existing post
- [ ] read() non-existent post
- [ ] update() existing post
- [ ] delete() existing post
- [ ] readAll() returns all posts
- [ ] readAll() returns empty list
- [ ] watchAllPosts() stream ordering

#### Acceptance Criteria
- [ ] All tests pass
- [ ] Uses FakeFirebaseFirestore
- [ ] Follows HaikuRepository test pattern
- [ ] Arrange-Act-Assert structure

---

### Task 1.8: Phase 1 Verification

**Type**: VERIFICATION
**Estimated Time**: 15 minutes
**Priority**: HIGH

#### Verification Steps

**Step 1.8.1**: Run code generation
```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

**Step 1.8.2**: Run static analysis
```bash
fvm flutter analyze
```

**Step 1.8.3**: Format code
```bash
dart format --set-exit-if-changed .
```

**Step 1.8.4**: Run all tests
```bash
fvm flutter test
```

**Step 1.8.5**: Run specific tests
```bash
# Post model tests
fvm flutter test test/features/posts/data/models/post_test.dart

# Repository tests
fvm flutter test test/features/posts/data/repositories/post_repository_test.dart
```

#### Expected Results
- ✅ Code generation: 0 errors
- ✅ Static analysis: 0 errors, 0 warnings
- ✅ Format: All files formatted
- ✅ Tests: All tests passing

#### Quality Gates
- [ ] All generated files exist
- [ ] No static analysis errors
- [ ] All code properly formatted
- [ ] All unit tests pass
- [ ] Test coverage >80%

---

## Phase 2: Enhanced Features (2-3 hours)

### Phase 2 Overview

| Task | File | Type | Estimated Time | Priority |
|------|------|------|---------------|----------|
| 2.1 | Infinite scroll | MODIFY | 1 hour | MEDIUM |
| 2.2 | PostCard widget tests | NEW | 45 min | MEDIUM |
| 2.3 | PostsPage widget tests | NEW | 1 hour | MEDIUM |
| 2.4 | Provider tests | NEW | 1 hour | MEDIUM |
| 2.5 | Performance optimization | MODIFY | 30 min | LOW |
| **TOTAL** | | | **~3-4 hours** | |

### Task 2.1: Implement Infinite Scroll

**File**: `lib/features/posts/presentation/pages/posts_page.dart`
**Type**: MODIFY
**Estimated Time**: 1 hour
**Priority**: MEDIUM

#### Implementation Strategy

**Step 2.1.1**: Add pagination provider
```dart
// In posts_provider.dart

/// ページネーション状態を管理するプロバイダー
@riverpod
class PostsPagination extends _$PostsPagination {
  static const int pageSize = 20;

  @override
  FutureOr<List<Post>> build() async {
    final repository = ref.read(postRepositoryProvider);
    final posts = await repository.readAll();
    return posts.take(pageSize).toList();
  }

  Future<void> loadMore() async {
    // Implementation for pagination
  }
}
```

**Step 2.1.2**: Add ScrollController in PostsPage
```dart
class PostsPage extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final scrollController = useScrollController();

    useEffect(() {
      void listener() {
        if (scrollController.position.pixels >=
            scrollController.position.maxScrollExtent * 0.9) {
          // Load more when 90% scrolled
          ref.read(postsPaginationProvider.notifier).loadMore();
        }
      }

      scrollController.addListener(listener);
      return () => scrollController.removeListener(listener);
    }, [scrollController]);

    // ... rest of implementation
  }
}
```

#### Note
This task is OPTIONAL for Phase 1 but RECOMMENDED for Phase 2

---

### Task 2.2: PostCard Widget Tests

**File**: `test/features/posts/presentation/widgets/post_card_test.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 45 minutes
**Priority**: MEDIUM

#### Implementation

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutterhackthema/features/posts/data/models/post.dart';
import 'package:flutterhackthema/features/posts/presentation/widgets/post_card.dart';

void main() {
  group('PostCard Widget', () {
    final testPost = Post(
      id: 'test-id',
      nickname: 'テストユーザー',
      haiku: '古池や\n蛙飛び込む\n水の音',
      imageUrl: 'https://example.com/image.jpg',
      createdAt: DateTime(2025, 1, 1),
    );

    testWidgets('renders correctly', (tester) async {
      // Arrange
      bool tapped = false;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: PostCard(
              post: testPost,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      // Assert
      expect(find.byType(PostCard), findsOneWidget);
      expect(find.byType(GestureDetector), findsOneWidget);
    });

    testWidgets('tap callback fires', (tester) async {
      // Arrange
      bool tapped = false;

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: PostCard(
              post: testPost,
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.byType(PostCard));
      await tester.pump();

      // Assert
      expect(tapped, isTrue);
    });

    testWidgets('displays 4:5 aspect ratio', (tester) async {
      // Arrange & Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: PostCard(
              post: testPost,
              onTap: () {},
            ),
          ),
        ),
      );

      // Assert
      final aspectRatio = tester.widget<AspectRatio>(
        find.byType(AspectRatio),
      );
      expect(aspectRatio.aspectRatio, equals(4 / 5));
    });
  });
}
```

---

### Task 2.3: PostsPage Widget Tests

**File**: `test/features/posts/presentation/pages/posts_page_test.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 1 hour
**Priority**: MEDIUM

#### Implementation Pattern

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:mockito/mockito.dart';

import 'package:flutterhackthema/features/posts/data/models/post.dart';
import 'package:flutterhackthema/features/posts/presentation/pages/posts_page.dart';
import 'package:flutterhackthema/features/posts/presentation/providers/posts_provider.dart';

void main() {
  group('PostsPage Widget', () {
    testWidgets('shows loading indicator while loading', (tester) async {
      // Arrange
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            postsStreamProvider.overrideWith(
              (ref) => Stream.value([]).map((event) => event),
            ),
          ],
          child: const MaterialApp(
            home: PostsPage(),
          ),
        ),
      );

      // Assert
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });

    testWidgets('shows error message on error', (tester) async {
      // Arrange
      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            postsStreamProvider.overrideWith(
              (ref) => Stream.error(Exception('Test error')),
            ),
          ],
          child: const MaterialApp(
            home: PostsPage(),
          ),
        ),
      );

      await tester.pumpAndSettle();

      // Assert
      expect(find.text('データの取得に失敗しました'), findsOneWidget);
      expect(find.byIcon(Icons.error_outline), findsOneWidget);
    });

    testWidgets('shows posts when data loaded', (tester) async {
      // Arrange
      final testPosts = [
        Post(
          id: '1',
          nickname: 'ユーザー1',
          haiku: '俳句1',
          imageUrl: 'https://example.com/1.jpg',
          createdAt: DateTime(2025, 1, 1),
        ),
        Post(
          id: '2',
          nickname: 'ユーザー2',
          haiku: '俳句2',
          imageUrl: 'https://example.com/2.jpg',
          createdAt: DateTime(2025, 1, 2),
        ),
      ];

      await tester.pumpWidget(
        ProviderScope(
          overrides: [
            postsStreamProvider.overrideWith(
              (ref) => Stream.value(testPosts),
            ),
          ],
          child: const MaterialApp(
            home: PostsPage(),
          ),
        ),
      );

      await tester.pumpAndSettle();

      // Assert
      expect(find.byType(PostCard), findsWidgets);
    });
  });
}
```

---

### Task 2.4: Provider Tests

**File**: `test/features/posts/presentation/providers/posts_provider_test.dart` (NEW)
**Type**: CREATE
**Estimated Time**: 1 hour
**Priority**: MEDIUM

#### Implementation Pattern

```dart
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'package:flutterhackthema/features/posts/data/models/post.dart';
import 'package:flutterhackthema/features/posts/data/repositories/post_repository.dart';
import 'package:flutterhackthema/features/posts/presentation/providers/posts_provider.dart';

class TestPostRepository extends PostRepository {
  TestPostRepository({required FakeFirebaseFirestore fakeFirestore})
      : _fakeFirestore = fakeFirestore;

  final FakeFirebaseFirestore _fakeFirestore;

  @override
  FirebaseFirestore get firestore => _fakeFirestore;
}

void main() {
  group('Posts Providers', () {
    late FakeFirebaseFirestore fakeFirestore;
    late ProviderContainer container;

    setUp(() {
      fakeFirestore = FakeFirebaseFirestore();
      container = ProviderContainer(
        overrides: [
          postRepositoryProvider.overrideWith(
            (ref) => TestPostRepository(fakeFirestore: fakeFirestore),
          ),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('postRepositoryProvider returns repository instance', () {
      // Act
      final repository = container.read(postRepositoryProvider);

      // Assert
      expect(repository, isA<PostRepository>());
    });

    test('postsStreamProvider emits data', () async {
      // Arrange
      final testPost = Post(
        id: 'test-id',
        nickname: 'テストユーザー',
        haiku: '古池や\n蛙飛び込む\n水の音',
        imageUrl: 'https://example.com/image.jpg',
        createdAt: DateTime(2025, 1, 1),
      );

      final repository = container.read(postRepositoryProvider);
      await repository.create(testPost, docId: 'test-id');

      // Act
      final stream = container.read(postsStreamProvider.stream);

      // Assert
      await expectLater(
        stream,
        emits((List<Post> posts) {
          expect(posts, hasLength(1));
          expect(posts.first.id, equals('test-id'));
          return true;
        }),
      );
    });
  });
}
```

---

## File Changes Summary

### Files to CREATE (8 new files)

1. `lib/features/posts/data/repositories/post_repository.dart`
2. `lib/features/posts/presentation/providers/posts_provider.dart`
3. `lib/features/posts/data/models/post.g.dart` (generated)
4. `lib/features/posts/presentation/providers/posts_provider.g.dart` (generated)
5. `test/features/posts/data/models/post_test.dart`
6. `test/features/posts/data/repositories/post_repository_test.dart`
7. `test/features/posts/presentation/widgets/post_card_test.dart`
8. `test/features/posts/presentation/pages/posts_page_test.dart`

### Files to MODIFY (2 files)

1. `lib/features/posts/data/models/post.dart`
   - Add @JsonSerializable annotation
   - Add part directive
   - Add fromJson/toJson methods
   - Remove mockPosts() method

2. `lib/features/posts/presentation/pages/posts_page.dart`
   - Change to HookConsumerWidget
   - Add Firestore integration
   - Add AsyncValue state handling
   - Remove mock data

### Files to DELETE (0 files)

None

---

## Tech Stack Verification

### Dependencies (Confirmed)

| Package | Version | Purpose | Status |
|---------|---------|---------|--------|
| hooks_riverpod | ^3.0.3 | State management | ✅ Installed |
| riverpod_annotation | latest | Provider code generation | ✅ Installed |
| go_router | ^16.2.4 | Routing | ✅ Installed |
| cloud_firestore | latest | Firestore SDK | ✅ Installed |
| json_annotation | latest | JSON serialization | ✅ Installed |
| build_runner | latest | Code generation | ✅ Installed (dev) |
| fake_cloud_firestore | latest | Firestore testing | ✅ Installed (dev) |
| flutter_test | SDK | Testing framework | ✅ Installed (dev) |
| very_good_analysis | ^10.0.0 | Static analysis | ✅ Installed (dev) |
| riverpod_lint | ^3.0.3 | Riverpod linting | ✅ Installed (dev) |

### No New Dependencies Required
All required packages already in pubspec.yaml

---

## Risk Analysis & Mitigation

### Technical Risks

#### Risk 1: Firestore Collection Schema Mismatch
**Level**: MEDIUM
**Impact**: Data not displaying correctly
**Mitigation**:
- Verify collection name ('posts') before deployment
- Test with Firestore emulator first
- Add schema validation in repository
- Document expected schema in code comments

#### Risk 2: Performance with Large Datasets
**Level**: MEDIUM
**Impact**: Slow loading, poor UX
**Mitigation**:
- Implement pagination (Phase 2)
- Limit initial query to 20 items
- Use Firestore indexing for createdAt field
- Monitor query performance with Logger

#### Risk 3: Network Image Loading Delays
**Level**: LOW
**Impact**: UI appears incomplete
**Mitigation**:
- Already mitigated: PostCard has loading indicators
- Consider: Add image caching in future
- Consider: Generate thumbnails for grid view

#### Risk 4: Real-time Listener Memory Leaks
**Level**: LOW
**Impact**: Memory consumption increases
**Mitigation**:
- Riverpod auto-disposes providers when not in use
- Use ref.onDispose for cleanup if needed
- Monitor memory usage during testing

### Integration Risks

#### Risk 5: Haiku-Post Relationship Unclear
**Level**: LOW
**Impact**: Confusion about data flow
**Decision Needed**: Are posts and haikus separate collections?

**Options**:
1. **Separate collections** (posts + haikus)
   - Posts reference haiku IDs
   - More normalized but complex
2. **Single collection** (posts only)
   - Denormalized haiku data in posts
   - Simpler but data duplication
3. **Haikus collection only** (rename to posts)
   - Treat haikus as posts
   - Simplest approach

**Recommendation**: Option 2 or 3 (clarify with team)

#### Risk 6: Nickname Integration
**Level**: LOW
**Impact**: Posts missing user context
**Mitigation**:
- Nickname stored with each post (denormalized)
- NicknameRepository pattern exists
- Verify nickname passed during post creation

---

## Test Strategy

### Test Coverage Goals

- **Unit Tests**: >80% coverage
- **Widget Tests**: All UI components
- **Integration Tests**: Optional but recommended

### Test Organization

```
test/
└── features/
    └── posts/
        ├── data/
        │   ├── models/
        │   │   └── post_test.dart
        │   └── repositories/
        │       └── post_repository_test.dart
        └── presentation/
            ├── providers/
            │   └── posts_provider_test.dart
            ├── widgets/
            │   └── post_card_test.dart
            └── pages/
                └── posts_page_test.dart
```

### Testing Tools

- **Unit Tests**: flutter_test
- **Mocking**: fake_cloud_firestore (for Firestore)
- **Widget Tests**: flutter_test with ProviderScope
- **Test Pattern**: Arrange-Act-Assert

### Test Execution

```bash
# Run all tests
fvm flutter test

# Run with coverage
fvm flutter test --coverage

# Run specific test file
fvm flutter test test/features/posts/data/repositories/post_repository_test.dart

# Run tests in watch mode
fvm flutter test --watch
```

---

## Implementation Checklist

### Phase 1: Core Firestore Integration

#### Prerequisites
- [x] Investigation complete
- [x] Plan approved
- [x] Branch created (feature/issue-12-posts-list)
- [ ] Firestore collection schema confirmed

#### Data Layer
- [ ] Post model refactored (@JsonSerializable)
- [ ] post.g.dart generated
- [ ] PostRepository created
- [ ] PostRepository implements fromFirestore()
- [ ] PostRepository implements toFirestore()
- [ ] PostRepository implements watchAllPosts()

#### Presentation Layer
- [ ] posts_provider.dart created
- [ ] Repository provider implemented
- [ ] Stream provider implemented
- [ ] posts_provider.g.dart generated
- [ ] PostsPage refactored to HookConsumerWidget
- [ ] AsyncValue state handling added
- [ ] Loading state implemented
- [ ] Error state implemented
- [ ] Empty state implemented
- [ ] Mock data removed

#### Testing
- [ ] Post model tests created
- [ ] Post model tests pass
- [ ] PostRepository tests created
- [ ] PostRepository tests pass
- [ ] Test coverage >80%

#### Quality Gates
- [ ] Code generation successful
- [ ] Static analysis passes (0 errors)
- [ ] Code formatted
- [ ] All tests passing
- [ ] Documentation complete (Japanese)

### Phase 2: Enhanced Features

#### Pagination
- [ ] Pagination provider created
- [ ] ScrollController added
- [ ] Load more logic implemented
- [ ] Loading indicator at bottom
- [ ] Pagination tests created

#### Widget Tests
- [ ] PostCard tests created
- [ ] PostCard tests pass
- [ ] PostsPage tests created
- [ ] PostsPage tests pass

#### Provider Tests
- [ ] Provider tests created
- [ ] Provider tests pass

#### Performance
- [ ] Query optimization reviewed
- [ ] Image loading optimized
- [ ] Memory usage verified

---

## Timeline & Milestones

### Phase 1 Timeline (3-4 hours)

| Milestone | Tasks | Duration | Cumulative |
|-----------|-------|----------|------------|
| **M1**: Model Ready | 1.1, 1.2 | 35 min | 35 min |
| **M2**: Repository Complete | 1.3, 1.6 | 1h 15m | 1h 50m |
| **M3**: Providers Ready | 1.4 | 30 min | 2h 20m |
| **M4**: UI Integration | 1.5 | 45 min | 3h 5m |
| **M5**: Tests Pass | 1.7, 1.8 | 1h 15m | 4h 20m |

### Phase 2 Timeline (2-3 hours)

| Milestone | Tasks | Duration | Cumulative |
|-----------|-------|----------|------------|
| **M6**: Pagination | 2.1 | 1 hour | 1h |
| **M7**: Widget Tests | 2.2, 2.3 | 1h 45m | 2h 45m |
| **M8**: Provider Tests | 2.4 | 1 hour | 3h 45m |
| **M9**: Optimization | 2.5 | 30 min | 4h 15m |

---

## Commands Reference

### Development Commands

```bash
# Install dependencies
fvm flutter pub get

# Code generation
fvm flutter pub run build_runner build --delete-conflicting-outputs

# Watch mode (auto-regenerate)
fvm flutter pub run build_runner watch --delete-conflicting-outputs

# Static analysis
fvm flutter analyze

# Format code
dart format --set-exit-if-changed .

# Run all tests
fvm flutter test

# Run tests with coverage
fvm flutter test --coverage

# Run specific test
fvm flutter test test/features/posts/data/repositories/post_repository_test.dart

# Hot reload Flutter app
fvm flutter run
```

### Git Commands

```bash
# Commit changes (Angular style)
git add .
git commit -m "feat(posts): implement Firestore integration for posts list

- Refactor Post model with @JsonSerializable
- Implement PostRepository extending FirestoreRepository
- Create Riverpod providers for posts stream
- Refactor PostsPage to use realtime Firestore data
- Add loading, error, and empty states
- Implement comprehensive unit tests

Closes #12"

# Push to remote
git push origin feature/issue-12-posts-list
```

---

## Success Metrics

### Functional Requirements
- [ ] Posts display from Firestore realtime
- [ ] Loading indicator shows during initial fetch
- [ ] Error message displays on Firestore errors
- [ ] Empty state shows when no posts exist
- [ ] FAB navigates to haiku creation
- [ ] Post cards navigate to detail page
- [ ] New posts appear automatically (realtime)

### Quality Requirements
- [ ] Zero static analysis errors
- [ ] Zero test failures
- [ ] Test coverage >80%
- [ ] All code properly formatted
- [ ] Japanese documentation complete
- [ ] Follows three-layer architecture
- [ ] No Feature-to-Feature dependencies

### Performance Requirements
- [ ] Initial load <2 seconds (local network)
- [ ] Smooth scrolling (60 FPS)
- [ ] No memory leaks
- [ ] Efficient Firestore queries

---

## Rollback Plan

### If Critical Issues Found

**Scenario 1**: Code generation fails
```bash
# Clean and retry
fvm flutter clean
fvm flutter pub get
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

**Scenario 2**: Tests fail
```bash
# Revert to last commit
git reset --hard HEAD~1

# Fix tests, then
git add .
git commit --amend
```

**Scenario 3**: Firestore integration broken
```bash
# Temporarily revert to mock data
# Comment out Firestore code
# Use Post.mockPosts() temporarily
# Debug and fix
```

**Scenario 4**: Critical bug in production
```bash
# Revert entire feature
git revert <commit-hash>
git push origin feature/issue-12-posts-list

# Create hotfix branch
git checkout -b hotfix/posts-critical-bug
```

---

## Next Steps After Plan Approval

1. **Confirm Firestore Schema**
   - Team review of proposed schema
   - Decide on haiku storage strategy
   - Confirm collection name

2. **Begin Phase 1 Implementation**
   - Start with Task 1.1 (Model refactoring)
   - Follow task order sequentially
   - Run verification after each major task

3. **Create GitHub Issue** (Optional)
   ```
   Title: feat(posts): Implement Firestore integration for posts list
   Labels: enhancement, Phase 2
   Milestone: Core Features
   Assignee: [Developer]
   ```

4. **Daily Standups**
   - Report progress on milestones
   - Raise blockers immediately
   - Share test results

---

## Appendix

### A. Firestore Schema Definition

```typescript
// Firestore Collection: posts
{
  "posts": {
    "{postId}": {
      "nickname": "string",        // User's nickname
      "haiku": "string",           // Full haiku text with \n
      "imageUrl": "string",        // Generated image URL
      "createdAt": "timestamp",    // Post creation time
      "likeCount": "number"        // Like count (default: 0)
    }
  }
}
```

### B. Provider Dependency Graph

```
postsStreamProvider
  └─> postRepositoryProvider
       └─> PostRepository
            └─> FirestoreRepository (Shared)
                 └─> FirebaseService (Shared)
```

### C. State Flow Diagram

```
User opens /posts
    ↓
PostsPage builds
    ↓
ref.watch(postsStreamProvider)
    ↓
postsStreamProvider activates
    ↓
PostRepository.watchAllPosts()
    ↓
Firestore realtime listener
    ↓
Stream emits List<Post>
    ↓
AsyncValue updates
    ↓
UI rebuilds
    ↓
[Loading] → [Data] or [Error]
```

### D. Reference Files

**Existing Patterns**:
- Model: `lib/features/haiku/data/models/haiku_model.dart`
- Repository: `lib/features/haiku/data/repositories/haiku_repository.dart`
- Provider: `lib/features/haiku/presentation/providers/haiku_provider.dart`
- Test: `test/features/haiku/data/repositories/haiku_repository_test.dart`

**Base Classes**:
- `lib/shared/data/repositories/firestore_repository.dart`
- `lib/shared/service/firebase_service.dart`

**Architecture**:
- `docs/ARCHITECTURE.md`
- `docs/STYLE_GUIDE.md`
- `CLAUDE.md`

---

**Plan Created**: 2025-11-30 07:42:36
**Next Phase**: IMPLEMENT
**Branch**: feature/issue-12-posts-list
**Planner**: Claude Code
