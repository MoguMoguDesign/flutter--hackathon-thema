# Investigation Report: Issue #12 - Posts List Screen Implementation

## Investigation Metadata

- **Issue**: #12 - みんなの投稿一覧画面の実装 2時間
- **Branch**: `feature/issue-12-posts-list`
- **Created**: 2025-11-30 07:37:58
- **Architecture Layer**: Feature (posts)
- **Status**: Investigation Complete

## Issue Summary

### Title
みんなの投稿一覧画面の実装 2時間

### Requirements
全ユーザーの俳句×画像投稿を一覧表示する画面の実装

### Task Checklist
- [ ] PostsPage ウィジェット作成
- [ ] Staggered Grid レイアウト（Pinterestライク）
- [ ] 投稿カードコンポーネント
  - 生成画像（4:5比率）
  - 俳句テキスト
  - ニックネーム
  - 投稿日時
- [ ] Firestoreからリアルタイムデータ取得
- [ ] 無限スクロール実装
- [ ] FAB（+ボタン）→ 新規投稿画面へ遷移
- [ ] ローディング・エラー状態の表示

### Priority
High (Phase 2: 機能実装)

### Dependencies
- ルーティング設定
- Postモデル・Repository

## Current Implementation Status

### Existing Files

#### 1. Posts Feature Files
```
lib/features/posts/
├── data/
│   └── models/
│       └── post.dart                    # Post model (simple class, not Freezed)
├── presentation/
│   ├── pages/
│   │   ├── posts_page.dart             # Posts list page (IMPLEMENTED with mock data)
│   │   └── post_detail_page.dart       # Post detail page
│   └── widgets/
│       └── post_card.dart              # Post card component (IMPLEMENTED)
```

#### 2. Routing Configuration
- `/posts` route already configured in `lib/app/app_router/routes.dart` (line 62-71)
- `/posts/:postId` route for detail page (line 83-95)

### Implementation Analysis

#### ✅ Already Implemented (UI Layer)

1. **PostsPage** (`lib/features/posts/presentation/pages/posts_page.dart`)
   - Status: IMPLEMENTED but using mock data
   - Features:
     - Staggered Grid layout (2-column Pinterest-style)
     - AppSliverHeader for scrollable header
     - FAB button with decorative SVG elements
     - Navigation to CreateRoute (haiku input page)
   - Current Data Source: `Post.mockPosts()` (line 33)
   - Mock Data: 6 sample posts with placeholder images from picsum.photos

2. **PostCard Widget** (`lib/features/posts/presentation/widgets/post_card.dart`)
   - Status: FULLY IMPLEMENTED
   - Features:
     - 4:5 aspect ratio (line 59)
     - Image loading with CircularProgressIndicator
     - Error handling with fallback icon
     - Tap gesture handling
     - Shadow and rounded corners

3. **Post Model** (`lib/features/posts/data/models/post.dart`)
   - Status: BASIC IMPLEMENTATION (not following project patterns)
   - Structure: Simple class (not Freezed, not JSON serializable)
   - Fields:
     - `id`: String
     - `nickname`: String
     - `haiku`: String
     - `imageUrl`: String
     - `createdAt`: DateTime
     - `likeCount`: int
   - Issue: Does not follow project standards (should use @JsonSerializable like HaikuModel)

#### ❌ Missing Implementation (Data Layer)

1. **Post Repository** - NOT IMPLEMENTED
   - Required: `lib/features/posts/data/repositories/post_repository.dart`
   - Should extend: `FirestoreRepository<PostModel>`
   - Collection path: `'posts'` (to be confirmed)
   - Methods needed:
     - `watchAll()` for realtime stream
     - Query with pagination for infinite scroll

2. **Riverpod Providers** - NOT IMPLEMENTED
   - Required: `lib/features/posts/presentation/providers/posts_provider.dart`
   - Providers needed:
     - `@riverpod PostRepository postRepository(Ref ref)`
     - `@riverpod Stream<List<PostModel>> postsStream(Ref ref)`
     - Pagination provider (optional, for infinite scroll)

3. **Firestore Integration** - NOT IMPLEMENTED
   - Posts collection schema needs definition
   - Realtime listener setup
   - Error handling for Firestore operations

4. **Infinite Scroll** - NOT IMPLEMENTED
   - Pagination logic
   - Load more trigger (ScrollController)
   - Loading indicator at bottom

5. **Global Loading/Error State** - PARTIAL IMPLEMENTATION
   - PostCard has image loading states
   - Missing: Overall loading state for initial data fetch
   - Missing: Error state UI for Firestore fetch failures

#### ❌ Missing Tests
- No test files exist for posts feature
- Required:
  - `test/features/posts/data/models/post_test.dart`
  - `test/features/posts/data/repositories/post_repository_test.dart`
  - `test/features/posts/presentation/providers/posts_provider_test.dart`
  - `test/features/posts/presentation/widgets/post_card_test.dart`
  - `test/features/posts/presentation/pages/posts_page_test.dart`

## Architectural Analysis

### Three-Layer Architecture Compliance

#### App Layer
- ✅ Routing configured: `/posts` and `/posts/:postId` routes exist
- ✅ Route guard: `nicknameGuard` applies to all routes
- ✅ No violations detected

#### Feature Layer (posts)
- ✅ Independent feature module structure
- ✅ No direct dependencies on other features
- ⚠️ Data layer incomplete (missing repository)
- ⚠️ Presentation layer incomplete (missing providers)

#### Shared Layer
- ✅ `FirestoreRepository<T>` base class available for extension
- ✅ `FirebaseService` provides Firestore instance
- ✅ Common UI components (AppScaffoldWithBackground, AppSliverHeader) used correctly

### Dependency Direction Analysis
- ✅ Posts feature only depends on Shared layer
- ✅ No Feature-to-Feature dependencies
- ✅ Routing configuration in App layer properly references posts feature

## Existing Patterns Analysis

### Repository Pattern (from HaikuRepository)

**Location**: `lib/features/haiku/data/repositories/haiku_repository.dart`

```dart
class HaikuRepository extends FirestoreRepository<HaikuModel> {
  HaikuRepository() : super(collectionPath: 'haikus');

  @override
  HaikuModel fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    final data = snapshot.data();
    return HaikuModel.fromJson({...data, 'id': snapshot.id});
  }

  @override
  Map<String, dynamic> toFirestore(HaikuModel data) {
    final json = data.toJson();
    json.remove('id'); // ID is document ID, not stored in data
    return json;
  }
}
```

**Key Patterns**:
1. Extend `FirestoreRepository<T>` from shared layer
2. Implement `fromFirestore()` and `toFirestore()`
3. Add document ID to model in `fromFirestore()`
4. Remove ID field in `toFirestore()` (Firestore manages it)
5. Use Logger for operation logging
6. Use stopwatch for performance monitoring

### Model Pattern (from HaikuModel)

**Location**: `lib/features/haiku/data/models/haiku_model.dart`

```dart
@JsonSerializable()
class HaikuModel {
  final String id;
  final String firstLine;
  final String secondLine;
  final String thirdLine;
  final DateTime createdAt;
  final String? imageUrl;

  const HaikuModel({
    required this.id,
    required this.firstLine,
    required this.secondLine,
    required this.thirdLine,
    required this.createdAt,
    this.imageUrl,
  });

  factory HaikuModel.fromJson(Map<String, dynamic> json) =>
      _$HaikuModelFromJson(json);

  Map<String, dynamic> toJson() => _$HaikuModelToJson(this);
}
```

**Key Patterns**:
1. Use `@JsonSerializable()` annotation (not Freezed for simple models)
2. Generate with `part 'model_name.g.dart'`
3. Provide `fromJson` and `toJson` methods
4. Use `const` constructor when possible
5. Required vs optional fields clearly marked

### Provider Pattern (from HaikuProvider)

**Location**: `lib/features/haiku/presentation/providers/haiku_provider.dart`

```dart
@riverpod
HaikuRepository haikuRepository(Ref ref) {
  return HaikuRepository();
}

@riverpod
class HaikuNotifier extends _$HaikuNotifier {
  @override
  FutureOr<String?> build() {
    return null;
  }

  Future<String> saveHaiku(...) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(haikuRepositoryProvider);
      // ... operation
    });
  }
}
```

**Key Patterns**:
1. Repository provider: Simple `@riverpod` function returning repository instance
2. Notifier provider: `@riverpod class` extending generated `_$ClassName`
3. Use `AsyncValue.guard()` for error handling
4. Use `AsyncValue.loading()` for loading states
5. Access repository via `ref.read(repositoryProvider)`

### Test Pattern (from HaikuRepositoryTest)

**Location**: `test/features/haiku/data/repositories/haiku_repository_test.dart`

```dart
class TestHaikuRepository extends HaikuRepository {
  TestHaikuRepository({required FakeFirebaseFirestore fakeFirestore})
    : _fakeFirestore = fakeFirestore;

  final FakeFirebaseFirestore _fakeFirestore;

  @override
  FirebaseFirestore get firestore => _fakeFirestore;
}

void main() {
  group('HaikuRepository', () {
    late FakeFirebaseFirestore fakeFirestore;
    late TestHaikuRepository repository;

    setUp(() {
      fakeFirestore = FakeFirebaseFirestore();
      repository = TestHaikuRepository(fakeFirestore: fakeFirestore);
    });

    test('creates haiku with auto-generated ID', () async {
      // Arrange-Act-Assert pattern
    });
  });
}
```

**Key Patterns**:
1. Use `FakeFirebaseFirestore` from `fake_cloud_firestore` package
2. Create test repository extending actual repository
3. Override `firestore` getter to inject fake instance
4. Use Arrange-Act-Assert pattern
5. Group related tests with `group()`
6. Setup common fixtures in `setUp()`

## Firestore Collection Schema (To Be Defined)

### Proposed Schema: `posts` Collection

```
posts/
  {postId}/
    nickname: string          # User's nickname
    haiku: string            # Full haiku text (3 lines with \n)
    imageUrl: string         # Generated image URL
    createdAt: timestamp     # Post creation timestamp
    likeCount: number        # Like count (default: 0)
```

### Considerations
1. **User Association**: Currently no userId field. Issue #12 doesn't mention user authentication.
2. **Haiku Structure**: Store as single string with newlines vs separate fields?
   - Current Post model uses single `haiku` field
   - HaikuModel uses `firstLine`, `secondLine`, `thirdLine`
   - Recommendation: Use separate fields for consistency with HaikuModel
3. **Indexing**: Need composite index for pagination (createdAt + documentId)

## Implementation Gap Analysis

### Required Changes

#### 1. Model Refactoring
**Priority**: HIGH
**File**: `lib/features/posts/data/models/post.dart`

**Changes**:
- Add `@JsonSerializable()` annotation
- Add `part 'post.g.dart'`
- Add `fromJson` factory constructor
- Add `toJson()` method
- Consider splitting `haiku` into `firstLine`, `secondLine`, `thirdLine` for consistency
- Add `copyWith()` method (optional, for state updates)

#### 2. Repository Implementation
**Priority**: HIGH
**File**: `lib/features/posts/data/repositories/post_repository.dart` (NEW)

**Implementation**:
```dart
class PostRepository extends FirestoreRepository<Post> {
  PostRepository() : super(collectionPath: 'posts');

  @override
  Post fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    // Implementation
  }

  @override
  Map<String, dynamic> toFirestore(Post data) {
    // Implementation
  }

  // Custom methods for pagination
  Stream<List<Post>> watchPaginated({
    int limit = 20,
    DocumentSnapshot? startAfter,
  }) {
    // Implementation with query
  }
}
```

#### 3. Provider Implementation
**Priority**: HIGH
**File**: `lib/features/posts/presentation/providers/posts_provider.dart` (NEW)

**Implementation**:
```dart
@riverpod
PostRepository postRepository(Ref ref) {
  return PostRepository();
}

@riverpod
Stream<List<Post>> postsStream(Ref ref) {
  final repository = ref.read(postRepositoryProvider);
  return repository.watchAll(
    query: repository.collection.orderBy('createdAt', descending: true),
  );
}
```

#### 4. PostsPage Refactoring
**Priority**: HIGH
**File**: `lib/features/posts/presentation/pages/posts_page.dart`

**Changes**:
- Change from `StatelessWidget` to `ConsumerWidget` or `HookConsumerWidget`
- Replace `Post.mockPosts()` with `ref.watch(postsStreamProvider)`
- Add AsyncValue handling (loading, error, data states)
- Implement infinite scroll with ScrollController
- Add pull-to-refresh functionality (optional)

#### 5. Testing Implementation
**Priority**: MEDIUM
**Files**: All test files listed in "Missing Tests" section

**Coverage Target**: Comprehensive (as per CLAUDE.md requirements)

#### 6. Code Generation
**Priority**: HIGH (before testing)
**Command**: `fvm flutter pub run build_runner build --delete-conflicting-outputs`

## Risk Analysis

### Technical Risks

#### 1. Firestore Collection Name Conflict
**Risk Level**: MEDIUM
**Description**: Posts collection may already exist with different schema
**Mitigation**:
- Check existing Firestore collections before implementation
- Use migration strategy if schema differs
- Consider versioning (posts_v1, posts_v2)

#### 2. Performance with Large Data Sets
**Risk Level**: MEDIUM
**Description**: Infinite scroll may cause performance issues with many posts
**Mitigation**:
- Implement pagination with reasonable limit (20-50 items)
- Use Firestore query cursors for efficient pagination
- Consider caching strategy with Riverpod

#### 3. Image Loading Performance
**Risk Level**: LOW
**Description**: Network images may load slowly
**Mitigation**:
- Already implemented: Loading indicators in PostCard
- Consider: Image caching with cached_network_image package
- Consider: Thumbnail generation for grid view

#### 4. Real-time Updates Performance
**Risk Level**: LOW
**Description**: Firestore realtime listeners consume resources
**Mitigation**:
- Use `watchAll()` stream which is already optimized
- Auto-dispose providers when not in use (Riverpod handles this)
- Limit initial query results

### Integration Risks

#### 1. Haiku Creation Integration
**Risk Level**: LOW
**Description**: Connection between haiku creation and posts display
**Mitigation**:
- Verify HaikuRepository saves to correct collection
- May need to create posts from haikus (transformation logic)
- Consider: Are haikus and posts the same or separate entities?

#### 2. Nickname Integration
**Risk Level**: LOW
**Description**: Posts need to display user nickname
**Mitigation**:
- Nickname is stored with each post (denormalized)
- NicknameRepository pattern already exists
- Verify nickname is passed to post creation

## Estimated Implementation Effort

### Task Breakdown

| Task | Estimated Time | Priority | Dependencies |
|------|---------------|----------|--------------|
| Model refactoring | 30 min | HIGH | None |
| Repository implementation | 45 min | HIGH | Model |
| Provider implementation | 30 min | HIGH | Repository |
| PostsPage refactoring | 1 hour | HIGH | Provider |
| Infinite scroll | 1 hour | MEDIUM | PostsPage |
| Unit tests (Repository) | 1 hour | HIGH | Repository |
| Widget tests (PostCard) | 45 min | MEDIUM | PostCard |
| Provider tests | 1 hour | MEDIUM | Provider |
| Integration testing | 45 min | LOW | All |
| **TOTAL** | **6-7 hours** | | |

### Critical Path
1. Model refactoring (30 min)
2. Code generation (5 min)
3. Repository implementation (45 min)
4. Provider implementation (30 min)
5. PostsPage refactoring (1 hour)
6. Basic testing (2 hours minimum)

**Minimum Viable Implementation**: 3 hours (excludes infinite scroll and comprehensive testing)

## Test Strategy

### Unit Tests (Required)

#### 1. Post Model Test
**File**: `test/features/posts/data/models/post_test.dart`
- JSON serialization/deserialization
- Field validation
- copyWith() functionality (if implemented)

#### 2. Post Repository Test
**File**: `test/features/posts/data/repositories/post_repository_test.dart`
- Pattern: Follow HaikuRepositoryTest pattern
- Tests:
  - create() with auto-generated ID
  - create() with custom ID
  - read() existing post
  - read() non-existent post (returns null)
  - update() existing post
  - delete() existing post
  - readAll() returns all posts
  - readAll() returns empty list
  - watchAll() stream emits updates
  - watchPaginated() with limit and cursor

#### 3. Posts Provider Test
**File**: `test/features/posts/presentation/providers/posts_provider_test.dart`
- postRepositoryProvider returns instance
- postsStreamProvider emits data
- Error handling in stream
- Loading states

### Widget Tests (Required)

#### 1. PostCard Test
**File**: `test/features/posts/presentation/widgets/post_card_test.dart`
- Renders correctly
- Tap callback fires
- Loading state displays
- Error state displays
- Image displays when loaded

#### 2. PostsPage Test
**File**: `test/features/posts/presentation/pages/posts_page_test.dart`
- Renders loading state
- Renders error state
- Renders post list
- FAB navigation works
- Tap on post navigates to detail
- Infinite scroll loads more (if implemented)

### Integration Tests (Optional)
**File**: `test/integration/posts_flow_test.dart`
- Full flow: View posts → Tap post → View detail
- Full flow: Create haiku → View in posts list

## Recommendations

### Implementation Approach

#### Option 1: Incremental Implementation (RECOMMENDED)
**Phases**:
1. **Phase 1** (3 hours): Core functionality
   - Refactor Post model
   - Implement PostRepository
   - Implement basic providers
   - Refactor PostsPage to use Firestore
   - Basic tests

2. **Phase 2** (2-3 hours): Enhanced features
   - Implement infinite scroll
   - Comprehensive testing
   - Error handling improvements
   - Performance optimization

**Advantages**:
- Demonstrates progress quickly
- Allows early testing of Firestore integration
- Easier to debug issues
- Aligns with agile development

**Disadvantages**:
- May require code changes between phases
- Testing twice (basic + comprehensive)

#### Option 2: Complete Implementation (Alternative)
**Approach**: Implement all requirements in single effort (6-7 hours)

**Advantages**:
- All features complete in one go
- Single comprehensive test suite
- No rework needed

**Disadvantages**:
- Longer time before visible progress
- Higher risk if issues found late
- Harder to track progress

### Recommended Approach
**Phase 1 (Incremental)** with following priorities:

**MUST HAVE** (Minimum for Issue #12 completion):
1. ✅ PostsPage UI (already done)
2. ✅ PostCard component (already done)
3. ✅ Staggered Grid layout (already done)
4. ✅ FAB navigation (already done)
5. ❌ Firestore realtime data fetch
6. ❌ Loading/Error states
7. ❌ Basic repository tests

**SHOULD HAVE** (Enhanced but not blocking):
1. ❌ Infinite scroll
2. ❌ Comprehensive widget tests
3. ❌ Performance optimization

**COULD HAVE** (Future enhancements):
1. Pull-to-refresh
2. Like functionality
3. Search/filter
4. Sorting options

## Next Steps

### Immediate Actions (PLAN Phase)

1. **Confirm Firestore Schema**
   - Review with team/stakeholder
   - Decide: Single `haiku` field vs `firstLine`/`secondLine`/`thirdLine`
   - Confirm collection name: `posts` or `haikus`?

2. **Clarify Requirements**
   - Is infinite scroll mandatory or nice-to-have?
   - What is expected error handling behavior?
   - Should posts and haikus be same collection?

3. **Create Implementation Plan**
   - Detailed task breakdown
   - File-by-file implementation steps
   - Test coverage plan
   - Risk mitigation strategies

4. **Prepare Development Environment**
   - Ensure Firestore emulator setup (for local testing)
   - Verify Firebase project configuration
   - Check Firestore rules allow read/write to posts collection

### PLAN Phase Deliverables

1. `docs/plan/plan_{TIMESTAMP}.md`
   - Detailed implementation strategy
   - File modification list
   - Code snippets for key implementations
   - Test plan with specific test cases
   - Risk mitigation steps
   - Timeline with milestones

2. Architecture decision documentation
3. Firestore schema definition
4. API contract for PostRepository

## Investigation Results Summary

### Status
✅ **Investigation Complete**

### Findings
1. ✅ Posts feature already has UI implementation (PostsPage, PostCard)
2. ✅ Routing already configured
3. ❌ Data layer completely missing (Repository, Providers)
4. ❌ Using mock data instead of Firestore
5. ❌ No tests exist for posts feature
6. ⚠️ Post model not following project patterns (needs refactoring)

### Architecture Compliance
- ✅ Three-layer architecture structure correct
- ✅ No Feature-to-Feature dependencies
- ✅ Proper dependency direction
- ⚠️ Data layer incomplete but no violations

### Effort Estimate
- **Minimum**: 3 hours (basic Firestore integration + essential tests)
- **Complete**: 6-7 hours (all requirements + comprehensive tests)
- **Recommended**: 3 hours Phase 1 → 2-3 hours Phase 2

### Risk Assessment
- **Overall Risk**: LOW-MEDIUM
- **Technical Risk**: MEDIUM (Firestore schema, performance)
- **Integration Risk**: LOW (patterns well-established)
- **Timeline Risk**: LOW (UI already done, saves significant time)

### Recommendation
✅ **PROCEED TO PLAN PHASE**

**Rationale**:
1. UI implementation significantly reduces effort (saves ~4-5 hours)
2. Clear implementation patterns exist (HaikuRepository, HaikuProvider)
3. No architectural violations found
4. Low integration risk
5. Well-defined scope with optional enhancements
6. Can deliver incremental value

**Suggested Strategy**:
- **Phase 1**: Core Firestore integration (3 hours)
- **Phase 2**: Infinite scroll + comprehensive tests (2-3 hours)
- **Total**: 5-6 hours realistic estimate

## Appendix

### Reference Files

#### Existing Implementation Examples
- `lib/shared/data/repositories/firestore_repository.dart` - Base repository
- `lib/features/haiku/data/repositories/haiku_repository.dart` - Repository example
- `lib/features/haiku/data/models/haiku_model.dart` - Model example
- `lib/features/haiku/presentation/providers/haiku_provider.dart` - Provider example
- `test/features/haiku/data/repositories/haiku_repository_test.dart` - Test example

#### Project Documentation
- `CLAUDE.md` - Project coding standards and architecture
- `docs/ARCHITECTURE.md` - Three-layer architecture details
- `docs/STYLE_GUIDE.md` - Code style guidelines

### Firestore Base Repository Methods

Available from `FirestoreRepository<T>` base class:
- `Future<String> create(T data, {String? docId})`
- `Future<T?> read(String docId)`
- `Future<void> update(String docId, T data)`
- `Future<void> delete(String docId)`
- `Future<List<T>> readAll()`
- `Stream<List<T>> watchAll({Query<Map<String, dynamic>>? query})`
- `Stream<T?> watch(String docId)`

### Technology Stack Verification

Confirmed dependencies from investigation:
- ✅ `cloud_firestore` - Firestore SDK
- ✅ `fake_cloud_firestore` - Testing support
- ✅ `hooks_riverpod` - State management
- ✅ `riverpod_annotation` - Provider code generation
- ✅ `go_router` - Navigation
- ✅ `json_annotation` - JSON serialization
- ✅ `build_runner` - Code generation
- ✅ `flutter_test` - Testing framework

### Command Reference

```bash
# Code generation
fvm flutter pub run build_runner build --delete-conflicting-outputs

# Watch mode (development)
fvm flutter pub run build_runner watch --delete-conflicting-outputs

# Static analysis
fvm flutter analyze

# Format code
dart format --set-exit-if-changed .

# Run tests
fvm flutter test

# Run specific test
fvm flutter test test/features/posts/data/repositories/post_repository_test.dart
```

---

**Investigation completed**: 2025-11-30 07:37:58
**Next phase**: PLAN
**Branch**: feature/issue-12-posts-list
**Investigator**: Claude Code
